Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ANDEQUAL
    APOSTROPHE
    ATTACH
    BREAK
    CASE
    CATCH
    CLASS
    COLON
    COMMENTS
    CONTAINS
    CONTINUE
    DECLARE
    DECREMENT
    DEFAULT
    DIVIDE
    DOT
    DOUBLECOLON
    ENDFOR
    ENDFOREACH
    ENDIF
    EXTENDS
    FIXEDARRAY
    FOR
    FORMAT
    GOTO
    HEAP
    INCREMENT
    INTDIVIDE
    LBRACKET
    MAXHEAP
    MINHEAP
    MODULE
    NOTIDENTICAL
    OBJECTSTORAGE
    PLUS
    POWERBY
    PRIORITYQUEUE
    PUBLIC
    RBRACKET
    SIMPLEARROW
    STATIC
    SWITCH
    TIMES
    TRY
    XOR

Grammar

Rule 0     S' -> sentence
Rule 1     sentence -> print
Rule 2     sentence -> printf
Rule 3     sentence -> assignment
Rule 4     sentence -> input
Rule 5     sentence -> function
Rule 6     sentence -> return
Rule 7     sentence -> echo
Rule 8     sentence -> array
Rule 9     sentence -> stack
Rule 10    sentence -> op_stack
Rule 11    sentence -> operad_stack
Rule 12    sentence -> if
Rule 13    sentence -> elseif
Rule 14    sentence -> else
Rule 15    sentence -> do
Rule 16    sentence -> die
Rule 17    sentence -> exit
Rule 18    sentence -> foreach
Rule 19    sentence -> while
Rule 20    assignment -> IDENTIFIER ASSINGMENT values SEMICOLON
Rule 21    print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 22    print -> PRINT value SEMICOLON
Rule 23    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 24    printf -> PRINTF LPAREN values RPAREN SEMICOLON
Rule 25    input -> FGETS LPAREN values RPAREN SEMICOLON
Rule 26    values -> value
Rule 27    values -> value COMMA values
Rule 28    value -> INTEGER
Rule 29    value -> FLOAT
Rule 30    value -> IDENTIFIER
Rule 31    value -> TRUE
Rule 32    value -> FALSE
Rule 33    value -> STRING
Rule 34    item -> value
Rule 35    item -> stack
Rule 36    item -> array
Rule 37    item -> queue
Rule 38    sign -> IDENTICAL
Rule 39    sign -> EQUALS
Rule 40    sign -> GREATERTHAN
Rule 41    sign -> GREATERTHANEQ
Rule 42    sign -> LESSTHAN
Rule 43    sign -> LESSTHANEQ
Rule 44    operator -> AND
Rule 45    operator -> OR
Rule 46    echo -> ECHO STRING SEMICOLON
Rule 47    while -> WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET
Rule 48    while -> CURLYRIGHTBRACKET WHILE LPAREN conditions RPAREN SEMICOLON
Rule 49    array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
Rule 50    items -> item repite_items
Rule 51    repite_items -> COMMA item
Rule 52    repite_items -> COMMA item repite_items
Rule 53    array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
Rule 54    itemsARROW -> item ARROW item repite_items_f
Rule 55    repite_items_f -> COMMA item ARROW item
Rule 56    repite_items_f -> COMMA item ARROW item repite_items
Rule 57    array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
Rule 58    queue -> NEW QUEUE LPAREN RPAREN
Rule 59    stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
Rule 60    op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack
Rule 61    operad_stack -> PUSH LPAREN values RPAREN SEMICOLON
Rule 62    operad_stack -> POP LPAREN RPAREN SEMICOLON
Rule 63    operad_stack -> COUNT LPAREN RPAREN SEMICOLON
Rule 64    operad_stack -> CURRENT LPAREN RPAREN SEMICOLON
Rule 65    function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
Rule 66    parameter -> IDENTIFIER
Rule 67    parameter -> IDENTIFIER COMMA parameter
Rule 68    function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
Rule 69    function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
Rule 70    return -> RETURN IDENTIFIER SEMICOLON
Rule 71    if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET
Rule 72    condition -> IDENTIFIER
Rule 73    condition -> IDENTIFIER sign value
Rule 74    conditions -> condition
Rule 75    conditions -> condition operator conditions
Rule 76    elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
Rule 77    elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
Rule 78    else -> ELSE CURLYLEFTBRACKET
Rule 79    else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET
Rule 80    do -> DO CURLYLEFTBRACKET
Rule 81    die -> DIE LPAREN STRING RPAREN SEMICOLON
Rule 82    exit -> EXIT LPAREN STRING RPAREN SEMICOLON
Rule 83    foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

Terminals, with rules where they appear

AND                  : 44
ANDEQUAL             : 
APOSTROPHE           : 
ARRAY                : 49 53 57
ARROW                : 54 55 56
ASSINGMENT           : 20 49 53 57 59 69
ATTACH               : 
BREAK                : 
CASE                 : 
CATCH                : 
CHAIN                : 53 57 83
CLASS                : 
COLON                : 
COMMA                : 27 51 52 55 56 67
COMMENTS             : 
CONTAINS             : 
CONTINUE             : 
COUNT                : 63
CURLYLEFTBRACKET     : 47 65 71 76 77 78 79 80 83
CURLYRIGHTBRACKET    : 48 77 79
CURRENT              : 64
DECLARE              : 
DECREMENT            : 
DEFAULT              : 
DIE                  : 81
DIVIDE               : 
DO                   : 80
DOLLARSIGN           : 53 57
DOT                  : 
DOUBLECOLON          : 
ECHO                 : 46
ELSE                 : 78 79
ELSEIF               : 76 77
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
EQUALS               : 39
EXIT                 : 82
EXTENDS              : 
FALSE                : 32
FGETS                : 25
FIXEDARRAY           : 
FLOAT                : 29
FOR                  : 
FOREACH              : 83
FORMAT               : 
FUNCTION             : 65
GOTO                 : 
GREATERTHAN          : 40 60
GREATERTHANEQ        : 41
HEAP                 : 
IDENTICAL            : 38
IDENTIFIER           : 20 30 49 59 60 66 67 69 70 72 73 83 83
IF                   : 71
INCREMENT            : 
INTDIVIDE            : 
INTEGER              : 28 49
LBRACKET             : 
LESSTHAN             : 42
LESSTHANEQ           : 43
LPAREN               : 21 23 24 25 47 48 49 53 57 58 59 61 62 63 64 65 68 69 71 76 77 81 82 83
MAXHEAP              : 
MINHEAP              : 
MINUS                : 60
MODULE               : 
NAMEFUNCTION         : 65 68 69
NEW                  : 58 59
NOTIDENTICAL         : 
OBJECTSTORAGE        : 
OR                   : 45
PLUS                 : 
POP                  : 62
POWERBY              : 
PRINT                : 21 22 23
PRINTF               : 24
PRIORITYQUEUE        : 
PUBLIC               : 
PUSH                 : 61
QUEUE                : 58
RBRACKET             : 
RETURN               : 70
RPAREN               : 21 23 24 25 47 48 49 53 57 58 59 61 62 63 64 65 68 69 71 76 77 81 82 83
SEMICOLON            : 20 21 22 23 24 25 46 48 49 53 57 59 61 62 63 64 68 69 70 81 82
SIMPLEARROW          : 
STACK                : 59
STATIC               : 
STRING               : 33 46 81 82
SWITCH               : 
TIMES                : 
TRUE                 : 31
TRY                  : 
WHILE                : 47 48
XOR                  : 
error                : 

Nonterminals, with rules where they appear

array                : 8 36
assignment           : 3
condition            : 74 75 76 77
conditions           : 47 48 71 75
die                  : 16
do                   : 15
echo                 : 7
else                 : 14
elseif               : 13
exit                 : 17
foreach              : 18
function             : 5
if                   : 12
input                : 4
item                 : 50 51 52 54 54 55 55 56 56
items                : 53
itemsARROW           : 57
op_stack             : 10
operad_stack         : 11 60
operator             : 75
parameter            : 65 67 68 69
print                : 1
printf               : 2
queue                : 37
repite_items         : 50 52 56
repite_items_f       : 54
return               : 6
sentence             : 0
sign                 : 73
stack                : 9 35
value                : 22 26 27 34 73
values               : 20 21 24 25 27 61
while                : 19

Parsing method: LALR

state 0

    (0) S' -> . sentence
    (1) sentence -> . print
    (2) sentence -> . printf
    (3) sentence -> . assignment
    (4) sentence -> . input
    (5) sentence -> . function
    (6) sentence -> . return
    (7) sentence -> . echo
    (8) sentence -> . array
    (9) sentence -> . stack
    (10) sentence -> . op_stack
    (11) sentence -> . operad_stack
    (12) sentence -> . if
    (13) sentence -> . elseif
    (14) sentence -> . else
    (15) sentence -> . do
    (16) sentence -> . die
    (17) sentence -> . exit
    (18) sentence -> . foreach
    (19) sentence -> . while
    (21) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (22) print -> . PRINT value SEMICOLON
    (23) print -> . PRINT LPAREN RPAREN SEMICOLON
    (24) printf -> . PRINTF LPAREN values RPAREN SEMICOLON
    (20) assignment -> . IDENTIFIER ASSINGMENT values SEMICOLON
    (25) input -> . FGETS LPAREN values RPAREN SEMICOLON
    (65) function -> . FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
    (68) function -> . NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (69) function -> . IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (70) return -> . RETURN IDENTIFIER SEMICOLON
    (46) echo -> . ECHO STRING SEMICOLON
    (49) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (53) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (59) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (60) op_stack -> . IDENTIFIER MINUS GREATERTHAN operad_stack
    (61) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (62) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (63) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (64) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON
    (71) if -> . IF LPAREN conditions RPAREN CURLYLEFTBRACKET
    (76) elseif -> . ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (77) elseif -> . CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (78) else -> . ELSE CURLYLEFTBRACKET
    (79) else -> . CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET
    (80) do -> . DO CURLYLEFTBRACKET
    (81) die -> . DIE LPAREN STRING RPAREN SEMICOLON
    (82) exit -> . EXIT LPAREN STRING RPAREN SEMICOLON
    (83) foreach -> . FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET
    (47) while -> . WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET
    (48) while -> . CURLYRIGHTBRACKET WHILE LPAREN conditions RPAREN SEMICOLON

    PRINT           shift and go to state 21
    PRINTF          shift and go to state 22
    IDENTIFIER      shift and go to state 23
    FGETS           shift and go to state 24
    FUNCTION        shift and go to state 25
    NAMEFUNCTION    shift and go to state 26
    RETURN          shift and go to state 27
    ECHO            shift and go to state 28
    DOLLARSIGN      shift and go to state 29
    PUSH            shift and go to state 30
    POP             shift and go to state 31
    COUNT           shift and go to state 32
    CURRENT         shift and go to state 33
    IF              shift and go to state 34
    ELSEIF          shift and go to state 35
    CURLYRIGHTBRACKET shift and go to state 36
    ELSE            shift and go to state 37
    DO              shift and go to state 38
    DIE             shift and go to state 39
    EXIT            shift and go to state 40
    FOREACH         shift and go to state 41
    WHILE           shift and go to state 42

    sentence                       shift and go to state 1
    print                          shift and go to state 2
    printf                         shift and go to state 3
    assignment                     shift and go to state 4
    input                          shift and go to state 5
    function                       shift and go to state 6
    return                         shift and go to state 7
    echo                           shift and go to state 8
    array                          shift and go to state 9
    stack                          shift and go to state 10
    op_stack                       shift and go to state 11
    operad_stack                   shift and go to state 12
    if                             shift and go to state 13
    elseif                         shift and go to state 14
    else                           shift and go to state 15
    do                             shift and go to state 16
    die                            shift and go to state 17
    exit                           shift and go to state 18
    foreach                        shift and go to state 19
    while                          shift and go to state 20

state 1

    (0) S' -> sentence .



state 2

    (1) sentence -> print .

    $end            reduce using rule 1 (sentence -> print .)


state 3

    (2) sentence -> printf .

    $end            reduce using rule 2 (sentence -> printf .)


state 4

    (3) sentence -> assignment .

    $end            reduce using rule 3 (sentence -> assignment .)


state 5

    (4) sentence -> input .

    $end            reduce using rule 4 (sentence -> input .)


state 6

    (5) sentence -> function .

    $end            reduce using rule 5 (sentence -> function .)


state 7

    (6) sentence -> return .

    $end            reduce using rule 6 (sentence -> return .)


state 8

    (7) sentence -> echo .

    $end            reduce using rule 7 (sentence -> echo .)


state 9

    (8) sentence -> array .

    $end            reduce using rule 8 (sentence -> array .)


state 10

    (9) sentence -> stack .

    $end            reduce using rule 9 (sentence -> stack .)


state 11

    (10) sentence -> op_stack .

    $end            reduce using rule 10 (sentence -> op_stack .)


state 12

    (11) sentence -> operad_stack .

    $end            reduce using rule 11 (sentence -> operad_stack .)


state 13

    (12) sentence -> if .

    $end            reduce using rule 12 (sentence -> if .)


state 14

    (13) sentence -> elseif .

    $end            reduce using rule 13 (sentence -> elseif .)


state 15

    (14) sentence -> else .

    $end            reduce using rule 14 (sentence -> else .)


state 16

    (15) sentence -> do .

    $end            reduce using rule 15 (sentence -> do .)


state 17

    (16) sentence -> die .

    $end            reduce using rule 16 (sentence -> die .)


state 18

    (17) sentence -> exit .

    $end            reduce using rule 17 (sentence -> exit .)


state 19

    (18) sentence -> foreach .

    $end            reduce using rule 18 (sentence -> foreach .)


state 20

    (19) sentence -> while .

    $end            reduce using rule 19 (sentence -> while .)


state 21

    (21) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (22) print -> PRINT . value SEMICOLON
    (23) print -> PRINT . LPAREN RPAREN SEMICOLON
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    LPAREN          shift and go to state 43
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    value                          shift and go to state 44

state 22

    (24) printf -> PRINTF . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 51


state 23

    (20) assignment -> IDENTIFIER . ASSINGMENT values SEMICOLON
    (69) function -> IDENTIFIER . ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (49) array -> IDENTIFIER . ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (59) stack -> IDENTIFIER . ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (60) op_stack -> IDENTIFIER . MINUS GREATERTHAN operad_stack

    ASSINGMENT      shift and go to state 52
    MINUS           shift and go to state 53


state 24

    (25) input -> FGETS . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 54


state 25

    (65) function -> FUNCTION . NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET

    NAMEFUNCTION    shift and go to state 55


state 26

    (68) function -> NAMEFUNCTION . LPAREN parameter RPAREN SEMICOLON

    LPAREN          shift and go to state 56


state 27

    (70) return -> RETURN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 57


state 28

    (46) echo -> ECHO . STRING SEMICOLON

    STRING          shift and go to state 58


state 29

    (53) array -> DOLLARSIGN . CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> DOLLARSIGN . CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON

    CHAIN           shift and go to state 59


state 30

    (61) operad_stack -> PUSH . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 60


state 31

    (62) operad_stack -> POP . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 61


state 32

    (63) operad_stack -> COUNT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 62


state 33

    (64) operad_stack -> CURRENT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 63


state 34

    (71) if -> IF . LPAREN conditions RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 64


state 35

    (76) elseif -> ELSEIF . LPAREN condition RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 65


state 36

    (77) elseif -> CURLYRIGHTBRACKET . ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (79) else -> CURLYRIGHTBRACKET . ELSE CURLYLEFTBRACKET
    (48) while -> CURLYRIGHTBRACKET . WHILE LPAREN conditions RPAREN SEMICOLON

    ELSEIF          shift and go to state 66
    ELSE            shift and go to state 67
    WHILE           shift and go to state 68


state 37

    (78) else -> ELSE . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 69


state 38

    (80) do -> DO . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 70


state 39

    (81) die -> DIE . LPAREN STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 71


state 40

    (82) exit -> EXIT . LPAREN STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 72


state 41

    (83) foreach -> FOREACH . LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 73


state 42

    (47) while -> WHILE . LPAREN conditions RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 74


state 43

    (21) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (23) print -> PRINT LPAREN . RPAREN SEMICOLON
    (26) values -> . value
    (27) values -> . value COMMA values
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    RPAREN          shift and go to state 76
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    values                         shift and go to state 75
    value                          shift and go to state 77

state 44

    (22) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 78


state 45

    (28) value -> INTEGER .

    SEMICOLON       reduce using rule 28 (value -> INTEGER .)
    COMMA           reduce using rule 28 (value -> INTEGER .)
    RPAREN          reduce using rule 28 (value -> INTEGER .)
    AND             reduce using rule 28 (value -> INTEGER .)
    OR              reduce using rule 28 (value -> INTEGER .)
    ARROW           reduce using rule 28 (value -> INTEGER .)


state 46

    (29) value -> FLOAT .

    SEMICOLON       reduce using rule 29 (value -> FLOAT .)
    COMMA           reduce using rule 29 (value -> FLOAT .)
    RPAREN          reduce using rule 29 (value -> FLOAT .)
    AND             reduce using rule 29 (value -> FLOAT .)
    OR              reduce using rule 29 (value -> FLOAT .)
    ARROW           reduce using rule 29 (value -> FLOAT .)


state 47

    (30) value -> IDENTIFIER .

    SEMICOLON       reduce using rule 30 (value -> IDENTIFIER .)
    COMMA           reduce using rule 30 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 30 (value -> IDENTIFIER .)
    AND             reduce using rule 30 (value -> IDENTIFIER .)
    OR              reduce using rule 30 (value -> IDENTIFIER .)


state 48

    (31) value -> TRUE .

    SEMICOLON       reduce using rule 31 (value -> TRUE .)
    COMMA           reduce using rule 31 (value -> TRUE .)
    RPAREN          reduce using rule 31 (value -> TRUE .)
    AND             reduce using rule 31 (value -> TRUE .)
    OR              reduce using rule 31 (value -> TRUE .)
    ARROW           reduce using rule 31 (value -> TRUE .)


state 49

    (32) value -> FALSE .

    SEMICOLON       reduce using rule 32 (value -> FALSE .)
    COMMA           reduce using rule 32 (value -> FALSE .)
    RPAREN          reduce using rule 32 (value -> FALSE .)
    AND             reduce using rule 32 (value -> FALSE .)
    OR              reduce using rule 32 (value -> FALSE .)
    ARROW           reduce using rule 32 (value -> FALSE .)


state 50

    (33) value -> STRING .

    SEMICOLON       reduce using rule 33 (value -> STRING .)
    COMMA           reduce using rule 33 (value -> STRING .)
    RPAREN          reduce using rule 33 (value -> STRING .)
    AND             reduce using rule 33 (value -> STRING .)
    OR              reduce using rule 33 (value -> STRING .)
    ARROW           reduce using rule 33 (value -> STRING .)


state 51

    (24) printf -> PRINTF LPAREN . values RPAREN SEMICOLON
    (26) values -> . value
    (27) values -> . value COMMA values
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    values                         shift and go to state 79
    value                          shift and go to state 77

state 52

    (20) assignment -> IDENTIFIER ASSINGMENT . values SEMICOLON
    (69) function -> IDENTIFIER ASSINGMENT . NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (49) array -> IDENTIFIER ASSINGMENT . ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (59) stack -> IDENTIFIER ASSINGMENT . NEW STACK LPAREN RPAREN SEMICOLON
    (26) values -> . value
    (27) values -> . value COMMA values
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    NAMEFUNCTION    shift and go to state 81
    ARRAY           shift and go to state 82
    NEW             shift and go to state 83
    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    values                         shift and go to state 80
    value                          shift and go to state 77

state 53

    (60) op_stack -> IDENTIFIER MINUS . GREATERTHAN operad_stack

    GREATERTHAN     shift and go to state 84


state 54

    (25) input -> FGETS LPAREN . values RPAREN SEMICOLON
    (26) values -> . value
    (27) values -> . value COMMA values
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    values                         shift and go to state 85
    value                          shift and go to state 77

state 55

    (65) function -> FUNCTION NAMEFUNCTION . LPAREN parameter RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 86


state 56

    (68) function -> NAMEFUNCTION LPAREN . parameter RPAREN SEMICOLON
    (66) parameter -> . IDENTIFIER
    (67) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 88

    parameter                      shift and go to state 87

state 57

    (70) return -> RETURN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 89


state 58

    (46) echo -> ECHO STRING . SEMICOLON

    SEMICOLON       shift and go to state 90


state 59

    (53) array -> DOLLARSIGN CHAIN . ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> DOLLARSIGN CHAIN . ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON

    ASSINGMENT      shift and go to state 91


state 60

    (61) operad_stack -> PUSH LPAREN . values RPAREN SEMICOLON
    (26) values -> . value
    (27) values -> . value COMMA values
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    values                         shift and go to state 92
    value                          shift and go to state 77

state 61

    (62) operad_stack -> POP LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 93


state 62

    (63) operad_stack -> COUNT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 94


state 63

    (64) operad_stack -> CURRENT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 95


state 64

    (71) if -> IF LPAREN . conditions RPAREN CURLYLEFTBRACKET
    (74) conditions -> . condition
    (75) conditions -> . condition operator conditions
    (72) condition -> . IDENTIFIER
    (73) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 98

    conditions                     shift and go to state 96
    condition                      shift and go to state 97

state 65

    (76) elseif -> ELSEIF LPAREN . condition RPAREN CURLYLEFTBRACKET
    (72) condition -> . IDENTIFIER
    (73) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 98

    condition                      shift and go to state 99

state 66

    (77) elseif -> CURLYRIGHTBRACKET ELSEIF . LPAREN condition RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 100


state 67

    (79) else -> CURLYRIGHTBRACKET ELSE . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 101


state 68

    (48) while -> CURLYRIGHTBRACKET WHILE . LPAREN conditions RPAREN SEMICOLON

    LPAREN          shift and go to state 102


state 69

    (78) else -> ELSE CURLYLEFTBRACKET .

    $end            reduce using rule 78 (else -> ELSE CURLYLEFTBRACKET .)


state 70

    (80) do -> DO CURLYLEFTBRACKET .

    $end            reduce using rule 80 (do -> DO CURLYLEFTBRACKET .)


state 71

    (81) die -> DIE LPAREN . STRING RPAREN SEMICOLON

    STRING          shift and go to state 103


state 72

    (82) exit -> EXIT LPAREN . STRING RPAREN SEMICOLON

    STRING          shift and go to state 104


state 73

    (83) foreach -> FOREACH LPAREN . IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

    IDENTIFIER      shift and go to state 105


state 74

    (47) while -> WHILE LPAREN . conditions RPAREN CURLYLEFTBRACKET
    (74) conditions -> . condition
    (75) conditions -> . condition operator conditions
    (72) condition -> . IDENTIFIER
    (73) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 98

    conditions                     shift and go to state 106
    condition                      shift and go to state 97

state 75

    (21) print -> PRINT LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 107


state 76

    (23) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 108


state 77

    (26) values -> value .
    (27) values -> value . COMMA values

    RPAREN          reduce using rule 26 (values -> value .)
    SEMICOLON       reduce using rule 26 (values -> value .)
    COMMA           shift and go to state 109


state 78

    (22) print -> PRINT value SEMICOLON .

    $end            reduce using rule 22 (print -> PRINT value SEMICOLON .)


state 79

    (24) printf -> PRINTF LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 110


state 80

    (20) assignment -> IDENTIFIER ASSINGMENT values . SEMICOLON

    SEMICOLON       shift and go to state 111


state 81

    (69) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION . LPAREN parameter RPAREN SEMICOLON

    LPAREN          shift and go to state 112


state 82

    (49) array -> IDENTIFIER ASSINGMENT ARRAY . LPAREN INTEGER RPAREN SEMICOLON

    LPAREN          shift and go to state 113


state 83

    (59) stack -> IDENTIFIER ASSINGMENT NEW . STACK LPAREN RPAREN SEMICOLON

    STACK           shift and go to state 114


state 84

    (60) op_stack -> IDENTIFIER MINUS GREATERTHAN . operad_stack
    (61) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (62) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (63) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (64) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON

    PUSH            shift and go to state 30
    POP             shift and go to state 31
    COUNT           shift and go to state 32
    CURRENT         shift and go to state 33

    operad_stack                   shift and go to state 115

state 85

    (25) input -> FGETS LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 116


state 86

    (65) function -> FUNCTION NAMEFUNCTION LPAREN . parameter RPAREN CURLYLEFTBRACKET
    (66) parameter -> . IDENTIFIER
    (67) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 88

    parameter                      shift and go to state 117

state 87

    (68) function -> NAMEFUNCTION LPAREN parameter . RPAREN SEMICOLON

    RPAREN          shift and go to state 118


state 88

    (66) parameter -> IDENTIFIER .
    (67) parameter -> IDENTIFIER . COMMA parameter

    RPAREN          reduce using rule 66 (parameter -> IDENTIFIER .)
    COMMA           shift and go to state 119


state 89

    (70) return -> RETURN IDENTIFIER SEMICOLON .

    $end            reduce using rule 70 (return -> RETURN IDENTIFIER SEMICOLON .)


state 90

    (46) echo -> ECHO STRING SEMICOLON .

    $end            reduce using rule 46 (echo -> ECHO STRING SEMICOLON .)


state 91

    (53) array -> DOLLARSIGN CHAIN ASSINGMENT . ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> DOLLARSIGN CHAIN ASSINGMENT . ARRAY LPAREN itemsARROW RPAREN SEMICOLON

    ARRAY           shift and go to state 120


state 92

    (61) operad_stack -> PUSH LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 121


state 93

    (62) operad_stack -> POP LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 122


state 94

    (63) operad_stack -> COUNT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 123


state 95

    (64) operad_stack -> CURRENT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 124


state 96

    (71) if -> IF LPAREN conditions . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 125


state 97

    (74) conditions -> condition .
    (75) conditions -> condition . operator conditions
    (44) operator -> . AND
    (45) operator -> . OR

    RPAREN          reduce using rule 74 (conditions -> condition .)
    AND             shift and go to state 127
    OR              shift and go to state 128

    operator                       shift and go to state 126

state 98

    (72) condition -> IDENTIFIER .
    (73) condition -> IDENTIFIER . sign value
    (38) sign -> . IDENTICAL
    (39) sign -> . EQUALS
    (40) sign -> . GREATERTHAN
    (41) sign -> . GREATERTHANEQ
    (42) sign -> . LESSTHAN
    (43) sign -> . LESSTHANEQ

    AND             reduce using rule 72 (condition -> IDENTIFIER .)
    OR              reduce using rule 72 (condition -> IDENTIFIER .)
    RPAREN          reduce using rule 72 (condition -> IDENTIFIER .)
    IDENTICAL       shift and go to state 130
    EQUALS          shift and go to state 131
    GREATERTHAN     shift and go to state 132
    GREATERTHANEQ   shift and go to state 133
    LESSTHAN        shift and go to state 134
    LESSTHANEQ      shift and go to state 135

    sign                           shift and go to state 129

state 99

    (76) elseif -> ELSEIF LPAREN condition . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 136


state 100

    (77) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN . condition RPAREN CURLYLEFTBRACKET
    (72) condition -> . IDENTIFIER
    (73) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 98

    condition                      shift and go to state 137

state 101

    (79) else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET .

    $end            reduce using rule 79 (else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET .)


state 102

    (48) while -> CURLYRIGHTBRACKET WHILE LPAREN . conditions RPAREN SEMICOLON
    (74) conditions -> . condition
    (75) conditions -> . condition operator conditions
    (72) condition -> . IDENTIFIER
    (73) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 98

    conditions                     shift and go to state 138
    condition                      shift and go to state 97

state 103

    (81) die -> DIE LPAREN STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 139


state 104

    (82) exit -> EXIT LPAREN STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 140


state 105

    (83) foreach -> FOREACH LPAREN IDENTIFIER . CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

    CHAIN           shift and go to state 141


state 106

    (47) while -> WHILE LPAREN conditions . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 142


state 107

    (21) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 143


state 108

    (23) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 23 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 109

    (27) values -> value COMMA . values
    (26) values -> . value
    (27) values -> . value COMMA values
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    value                          shift and go to state 77
    values                         shift and go to state 144

state 110

    (24) printf -> PRINTF LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 145


state 111

    (20) assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .

    $end            reduce using rule 20 (assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .)


state 112

    (69) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN . parameter RPAREN SEMICOLON
    (66) parameter -> . IDENTIFIER
    (67) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 88

    parameter                      shift and go to state 146

state 113

    (49) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN . INTEGER RPAREN SEMICOLON

    INTEGER         shift and go to state 147


state 114

    (59) stack -> IDENTIFIER ASSINGMENT NEW STACK . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 148


state 115

    (60) op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .

    $end            reduce using rule 60 (op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .)


state 116

    (25) input -> FGETS LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 149


state 117

    (65) function -> FUNCTION NAMEFUNCTION LPAREN parameter . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 150


state 118

    (68) function -> NAMEFUNCTION LPAREN parameter RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 151


state 119

    (67) parameter -> IDENTIFIER COMMA . parameter
    (66) parameter -> . IDENTIFIER
    (67) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 88

    parameter                      shift and go to state 152

state 120

    (53) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY . LPAREN items RPAREN SEMICOLON
    (57) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY . LPAREN itemsARROW RPAREN SEMICOLON

    LPAREN          shift and go to state 153


state 121

    (61) operad_stack -> PUSH LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 154


state 122

    (62) operad_stack -> POP LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 62 (operad_stack -> POP LPAREN RPAREN SEMICOLON .)


state 123

    (63) operad_stack -> COUNT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 63 (operad_stack -> COUNT LPAREN RPAREN SEMICOLON .)


state 124

    (64) operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 64 (operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .)


state 125

    (71) if -> IF LPAREN conditions RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 155


state 126

    (75) conditions -> condition operator . conditions
    (74) conditions -> . condition
    (75) conditions -> . condition operator conditions
    (72) condition -> . IDENTIFIER
    (73) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 98

    condition                      shift and go to state 97
    conditions                     shift and go to state 156

state 127

    (44) operator -> AND .

    IDENTIFIER      reduce using rule 44 (operator -> AND .)


state 128

    (45) operator -> OR .

    IDENTIFIER      reduce using rule 45 (operator -> OR .)


state 129

    (73) condition -> IDENTIFIER sign . value
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 47
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50

    value                          shift and go to state 157

state 130

    (38) sign -> IDENTICAL .

    INTEGER         reduce using rule 38 (sign -> IDENTICAL .)
    FLOAT           reduce using rule 38 (sign -> IDENTICAL .)
    IDENTIFIER      reduce using rule 38 (sign -> IDENTICAL .)
    TRUE            reduce using rule 38 (sign -> IDENTICAL .)
    FALSE           reduce using rule 38 (sign -> IDENTICAL .)
    STRING          reduce using rule 38 (sign -> IDENTICAL .)


state 131

    (39) sign -> EQUALS .

    INTEGER         reduce using rule 39 (sign -> EQUALS .)
    FLOAT           reduce using rule 39 (sign -> EQUALS .)
    IDENTIFIER      reduce using rule 39 (sign -> EQUALS .)
    TRUE            reduce using rule 39 (sign -> EQUALS .)
    FALSE           reduce using rule 39 (sign -> EQUALS .)
    STRING          reduce using rule 39 (sign -> EQUALS .)


state 132

    (40) sign -> GREATERTHAN .

    INTEGER         reduce using rule 40 (sign -> GREATERTHAN .)
    FLOAT           reduce using rule 40 (sign -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 40 (sign -> GREATERTHAN .)
    TRUE            reduce using rule 40 (sign -> GREATERTHAN .)
    FALSE           reduce using rule 40 (sign -> GREATERTHAN .)
    STRING          reduce using rule 40 (sign -> GREATERTHAN .)


state 133

    (41) sign -> GREATERTHANEQ .

    INTEGER         reduce using rule 41 (sign -> GREATERTHANEQ .)
    FLOAT           reduce using rule 41 (sign -> GREATERTHANEQ .)
    IDENTIFIER      reduce using rule 41 (sign -> GREATERTHANEQ .)
    TRUE            reduce using rule 41 (sign -> GREATERTHANEQ .)
    FALSE           reduce using rule 41 (sign -> GREATERTHANEQ .)
    STRING          reduce using rule 41 (sign -> GREATERTHANEQ .)


state 134

    (42) sign -> LESSTHAN .

    INTEGER         reduce using rule 42 (sign -> LESSTHAN .)
    FLOAT           reduce using rule 42 (sign -> LESSTHAN .)
    IDENTIFIER      reduce using rule 42 (sign -> LESSTHAN .)
    TRUE            reduce using rule 42 (sign -> LESSTHAN .)
    FALSE           reduce using rule 42 (sign -> LESSTHAN .)
    STRING          reduce using rule 42 (sign -> LESSTHAN .)


state 135

    (43) sign -> LESSTHANEQ .

    INTEGER         reduce using rule 43 (sign -> LESSTHANEQ .)
    FLOAT           reduce using rule 43 (sign -> LESSTHANEQ .)
    IDENTIFIER      reduce using rule 43 (sign -> LESSTHANEQ .)
    TRUE            reduce using rule 43 (sign -> LESSTHANEQ .)
    FALSE           reduce using rule 43 (sign -> LESSTHANEQ .)
    STRING          reduce using rule 43 (sign -> LESSTHANEQ .)


state 136

    (76) elseif -> ELSEIF LPAREN condition RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 158


state 137

    (77) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 159


state 138

    (48) while -> CURLYRIGHTBRACKET WHILE LPAREN conditions . RPAREN SEMICOLON

    RPAREN          shift and go to state 160


state 139

    (81) die -> DIE LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 161


state 140

    (82) exit -> EXIT LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 162


state 141

    (83) foreach -> FOREACH LPAREN IDENTIFIER CHAIN . IDENTIFIER RPAREN CURLYLEFTBRACKET

    IDENTIFIER      shift and go to state 163


state 142

    (47) while -> WHILE LPAREN conditions RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 164


state 143

    (21) print -> PRINT LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 21 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 144

    (27) values -> value COMMA values .

    RPAREN          reduce using rule 27 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 27 (values -> value COMMA values .)


state 145

    (24) printf -> PRINTF LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 24 (printf -> PRINTF LPAREN values RPAREN SEMICOLON .)


state 146

    (69) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter . RPAREN SEMICOLON

    RPAREN          shift and go to state 165


state 147

    (49) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER . RPAREN SEMICOLON

    RPAREN          shift and go to state 166


state 148

    (59) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 167


state 149

    (25) input -> FGETS LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 25 (input -> FGETS LPAREN values RPAREN SEMICOLON .)


state 150

    (65) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 168


state 151

    (68) function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .

    $end            reduce using rule 68 (function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .)


state 152

    (67) parameter -> IDENTIFIER COMMA parameter .

    RPAREN          reduce using rule 67 (parameter -> IDENTIFIER COMMA parameter .)


state 153

    (53) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN . items RPAREN SEMICOLON
    (57) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN . itemsARROW RPAREN SEMICOLON
    (50) items -> . item repite_items
    (54) itemsARROW -> . item ARROW item repite_items_f
    (34) item -> . value
    (35) item -> . stack
    (36) item -> . array
    (37) item -> . queue
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING
    (59) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (49) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (53) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (58) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 176
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50
    DOLLARSIGN      shift and go to state 29
    NEW             shift and go to state 177

    items                          shift and go to state 169
    itemsARROW                     shift and go to state 170
    item                           shift and go to state 171
    value                          shift and go to state 172
    stack                          shift and go to state 173
    array                          shift and go to state 174
    queue                          shift and go to state 175

state 154

    (61) operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 61 (operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .)


state 155

    (71) if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 71 (if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET .)


state 156

    (75) conditions -> condition operator conditions .

    RPAREN          reduce using rule 75 (conditions -> condition operator conditions .)


state 157

    (73) condition -> IDENTIFIER sign value .

    AND             reduce using rule 73 (condition -> IDENTIFIER sign value .)
    OR              reduce using rule 73 (condition -> IDENTIFIER sign value .)
    RPAREN          reduce using rule 73 (condition -> IDENTIFIER sign value .)


state 158

    (76) elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 76 (elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .)


state 159

    (77) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 178


state 160

    (48) while -> CURLYRIGHTBRACKET WHILE LPAREN conditions RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 179


state 161

    (81) die -> DIE LPAREN STRING RPAREN SEMICOLON .

    $end            reduce using rule 81 (die -> DIE LPAREN STRING RPAREN SEMICOLON .)


state 162

    (82) exit -> EXIT LPAREN STRING RPAREN SEMICOLON .

    $end            reduce using rule 82 (exit -> EXIT LPAREN STRING RPAREN SEMICOLON .)


state 163

    (83) foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 180


state 164

    (47) while -> WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 47 (while -> WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET .)


state 165

    (69) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 181


state 166

    (49) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 182


state 167

    (59) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 183


state 168

    (65) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 65 (function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .)


state 169

    (53) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items . RPAREN SEMICOLON

    RPAREN          shift and go to state 184


state 170

    (57) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW . RPAREN SEMICOLON

    RPAREN          shift and go to state 185


state 171

    (50) items -> item . repite_items
    (54) itemsARROW -> item . ARROW item repite_items_f
    (51) repite_items -> . COMMA item
    (52) repite_items -> . COMMA item repite_items

    ARROW           shift and go to state 187
    COMMA           shift and go to state 188

    repite_items                   shift and go to state 186

state 172

    (34) item -> value .

    ARROW           reduce using rule 34 (item -> value .)
    COMMA           reduce using rule 34 (item -> value .)
    RPAREN          reduce using rule 34 (item -> value .)


state 173

    (35) item -> stack .

    ARROW           reduce using rule 35 (item -> stack .)
    COMMA           reduce using rule 35 (item -> stack .)
    RPAREN          reduce using rule 35 (item -> stack .)


state 174

    (36) item -> array .

    ARROW           reduce using rule 36 (item -> array .)
    COMMA           reduce using rule 36 (item -> array .)
    RPAREN          reduce using rule 36 (item -> array .)


state 175

    (37) item -> queue .

    ARROW           reduce using rule 37 (item -> queue .)
    COMMA           reduce using rule 37 (item -> queue .)
    RPAREN          reduce using rule 37 (item -> queue .)


state 176

    (30) value -> IDENTIFIER .
    (59) stack -> IDENTIFIER . ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (49) array -> IDENTIFIER . ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON

    ARROW           reduce using rule 30 (value -> IDENTIFIER .)
    COMMA           reduce using rule 30 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 30 (value -> IDENTIFIER .)
    ASSINGMENT      shift and go to state 189


state 177

    (58) queue -> NEW . QUEUE LPAREN RPAREN

    QUEUE           shift and go to state 190


state 178

    (77) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 77 (elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .)


state 179

    (48) while -> CURLYRIGHTBRACKET WHILE LPAREN conditions RPAREN SEMICOLON .

    $end            reduce using rule 48 (while -> CURLYRIGHTBRACKET WHILE LPAREN conditions RPAREN SEMICOLON .)


state 180

    (83) foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 191


state 181

    (69) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .

    $end            reduce using rule 69 (function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .)


state 182

    (49) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .

    $end            reduce using rule 49 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)
    ARROW           reduce using rule 49 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)
    COMMA           reduce using rule 49 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)
    RPAREN          reduce using rule 49 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)


state 183

    (59) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 59 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)
    ARROW           reduce using rule 59 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)
    COMMA           reduce using rule 59 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 59 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)


state 184

    (53) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 192


state 185

    (57) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 193


state 186

    (50) items -> item repite_items .

    RPAREN          reduce using rule 50 (items -> item repite_items .)


state 187

    (54) itemsARROW -> item ARROW . item repite_items_f
    (34) item -> . value
    (35) item -> . stack
    (36) item -> . array
    (37) item -> . queue
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING
    (59) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (49) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (53) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (58) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 176
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50
    DOLLARSIGN      shift and go to state 29
    NEW             shift and go to state 177

    item                           shift and go to state 194
    value                          shift and go to state 172
    stack                          shift and go to state 173
    array                          shift and go to state 174
    queue                          shift and go to state 175

state 188

    (51) repite_items -> COMMA . item
    (52) repite_items -> COMMA . item repite_items
    (34) item -> . value
    (35) item -> . stack
    (36) item -> . array
    (37) item -> . queue
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING
    (59) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (49) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (53) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (58) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 176
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50
    DOLLARSIGN      shift and go to state 29
    NEW             shift and go to state 177

    item                           shift and go to state 195
    value                          shift and go to state 172
    stack                          shift and go to state 173
    array                          shift and go to state 174
    queue                          shift and go to state 175

state 189

    (59) stack -> IDENTIFIER ASSINGMENT . NEW STACK LPAREN RPAREN SEMICOLON
    (49) array -> IDENTIFIER ASSINGMENT . ARRAY LPAREN INTEGER RPAREN SEMICOLON

    NEW             shift and go to state 83
    ARRAY           shift and go to state 82


state 190

    (58) queue -> NEW QUEUE . LPAREN RPAREN

    LPAREN          shift and go to state 196


state 191

    (83) foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 83 (foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET .)


state 192

    (53) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .

    $end            reduce using rule 53 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)
    ARROW           reduce using rule 53 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)
    COMMA           reduce using rule 53 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)
    RPAREN          reduce using rule 53 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)


state 193

    (57) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .

    $end            reduce using rule 57 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)
    ARROW           reduce using rule 57 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)
    COMMA           reduce using rule 57 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)
    RPAREN          reduce using rule 57 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)


state 194

    (54) itemsARROW -> item ARROW item . repite_items_f
    (55) repite_items_f -> . COMMA item ARROW item
    (56) repite_items_f -> . COMMA item ARROW item repite_items

    COMMA           shift and go to state 198

    repite_items_f                 shift and go to state 197

state 195

    (51) repite_items -> COMMA item .
    (52) repite_items -> COMMA item . repite_items
    (51) repite_items -> . COMMA item
    (52) repite_items -> . COMMA item repite_items

    RPAREN          reduce using rule 51 (repite_items -> COMMA item .)
    COMMA           shift and go to state 188

    repite_items                   shift and go to state 199

state 196

    (58) queue -> NEW QUEUE LPAREN . RPAREN

    RPAREN          shift and go to state 200


state 197

    (54) itemsARROW -> item ARROW item repite_items_f .

    RPAREN          reduce using rule 54 (itemsARROW -> item ARROW item repite_items_f .)


state 198

    (55) repite_items_f -> COMMA . item ARROW item
    (56) repite_items_f -> COMMA . item ARROW item repite_items
    (34) item -> . value
    (35) item -> . stack
    (36) item -> . array
    (37) item -> . queue
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING
    (59) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (49) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (53) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (58) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 176
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50
    DOLLARSIGN      shift and go to state 29
    NEW             shift and go to state 177

    item                           shift and go to state 201
    value                          shift and go to state 172
    stack                          shift and go to state 173
    array                          shift and go to state 174
    queue                          shift and go to state 175

state 199

    (52) repite_items -> COMMA item repite_items .

    RPAREN          reduce using rule 52 (repite_items -> COMMA item repite_items .)


state 200

    (58) queue -> NEW QUEUE LPAREN RPAREN .

    ARROW           reduce using rule 58 (queue -> NEW QUEUE LPAREN RPAREN .)
    COMMA           reduce using rule 58 (queue -> NEW QUEUE LPAREN RPAREN .)
    RPAREN          reduce using rule 58 (queue -> NEW QUEUE LPAREN RPAREN .)


state 201

    (55) repite_items_f -> COMMA item . ARROW item
    (56) repite_items_f -> COMMA item . ARROW item repite_items

    ARROW           shift and go to state 202


state 202

    (55) repite_items_f -> COMMA item ARROW . item
    (56) repite_items_f -> COMMA item ARROW . item repite_items
    (34) item -> . value
    (35) item -> . stack
    (36) item -> . array
    (37) item -> . queue
    (28) value -> . INTEGER
    (29) value -> . FLOAT
    (30) value -> . IDENTIFIER
    (31) value -> . TRUE
    (32) value -> . FALSE
    (33) value -> . STRING
    (59) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (49) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (53) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (57) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (58) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    IDENTIFIER      shift and go to state 176
    TRUE            shift and go to state 48
    FALSE           shift and go to state 49
    STRING          shift and go to state 50
    DOLLARSIGN      shift and go to state 29
    NEW             shift and go to state 177

    item                           shift and go to state 203
    value                          shift and go to state 172
    stack                          shift and go to state 173
    array                          shift and go to state 174
    queue                          shift and go to state 175

state 203

    (55) repite_items_f -> COMMA item ARROW item .
    (56) repite_items_f -> COMMA item ARROW item . repite_items
    (51) repite_items -> . COMMA item
    (52) repite_items -> . COMMA item repite_items

    RPAREN          reduce using rule 55 (repite_items_f -> COMMA item ARROW item .)
    COMMA           shift and go to state 188

    repite_items                   shift and go to state 204

state 204

    (56) repite_items_f -> COMMA item ARROW item repite_items .

    RPAREN          reduce using rule 56 (repite_items_f -> COMMA item ARROW item repite_items .)

