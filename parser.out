Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ANDEQUAL
    APOSTROPHE
    ARROW
    ATTACH
    BREAK
    CASE
    CATCH
    CHAIN
    CLASS
    COLON
    COMMENTS
    CONTAINS
    CONTINUE
    DECLARE
    DECREMENT
    DEFAULT
    DIE
    DIVIDE
    DO
    DOLLARSIGN
    DOT
    DOUBLECOLON
    ENDFOR
    ENDFOREACH
    ENDIF
    EXIT
    EXTENDS
    FIXEDARRAY
    FOR
    FOREACH
    FORMAT
    GOTO
    HEAP
    INCREMENT
    INTDIVIDE
    LBRACKET
    MAXHEAP
    MINHEAP
    MODULE
    NOTIDENTICAL
    OBJECTSTORAGE
    PLUS
    POWERBY
    PRIORITYQUEUE
    PUBLIC
    QUEUE
    RBRACKET
    SIMPLEARROW
    STATIC
    SWITCH
    TIMES
    TRY
    XOR

Grammar

Rule 0     S' -> sentence
Rule 1     sentence -> print
Rule 2     sentence -> printf
Rule 3     sentence -> assignment
Rule 4     sentence -> input
Rule 5     sentence -> function
Rule 6     sentence -> return
Rule 7     sentence -> echo
Rule 8     sentence -> array
Rule 9     sentence -> stack
Rule 10    sentence -> op_stack
Rule 11    sentence -> operad_stack
Rule 12    sentence -> if
Rule 13    sentence -> elseif
Rule 14    sentence -> else
Rule 15    sentence -> while
Rule 16    assignment -> IDENTIFIER ASSINGMENT values SEMICOLON
Rule 17    print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 18    print -> PRINT value SEMICOLON
Rule 19    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 20    printf -> PRINTF LPAREN values RPAREN SEMICOLON
Rule 21    input -> FGETS LPAREN values RPAREN SEMICOLON
Rule 22    values -> value
Rule 23    values -> value COMMA values
Rule 24    value -> INTEGER
Rule 25    value -> FLOAT
Rule 26    value -> IDENTIFIER
Rule 27    value -> TRUE
Rule 28    value -> FALSE
Rule 29    value -> STRING
Rule 30    sign -> IDENTICAL
Rule 31    sign -> EQUALS
Rule 32    sign -> GREATERTHAN
Rule 33    sign -> GREATERTHANEQ
Rule 34    sign -> LESSTHAN
Rule 35    sign -> LESSTHANEQ
Rule 36    operator -> AND
Rule 37    operator -> OR
Rule 38    echo -> ECHO STRING SEMICOLON
Rule 39    while -> WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET
Rule 40    array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
Rule 41    stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
Rule 42    op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack
Rule 43    operad_stack -> PUSH LPAREN values RPAREN SEMICOLON
Rule 44    operad_stack -> POP LPAREN RPAREN SEMICOLON
Rule 45    operad_stack -> COUNT LPAREN RPAREN SEMICOLON
Rule 46    operad_stack -> CURRENT LPAREN RPAREN SEMICOLON
Rule 47    function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
Rule 48    parameter -> IDENTIFIER
Rule 49    parameter -> IDENTIFIER COMMA parameter
Rule 50    function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
Rule 51    function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
Rule 52    return -> RETURN IDENTIFIER SEMICOLON
Rule 53    if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET
Rule 54    condition -> IDENTIFIER
Rule 55    condition -> IDENTIFIER sign value
Rule 56    conditions -> condition
Rule 57    conditions -> condition operator conditions
Rule 58    elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
Rule 59    elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
Rule 60    else -> ELSE CURLYLEFTBRACKET
Rule 61    else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET

Terminals, with rules where they appear

AND                  : 36
ANDEQUAL             : 
APOSTROPHE           : 
ARRAY                : 40
ARROW                : 
ASSINGMENT           : 16 40 41 51
ATTACH               : 
BREAK                : 
CASE                 : 
CATCH                : 
CHAIN                : 
CLASS                : 
COLON                : 
COMMA                : 23 49
COMMENTS             : 
CONTAINS             : 
CONTINUE             : 
COUNT                : 45
CURLYLEFTBRACKET     : 39 47 53 58 59 60 61
CURLYRIGHTBRACKET    : 59 61
CURRENT              : 46
DECLARE              : 
DECREMENT            : 
DEFAULT              : 
DIE                  : 
DIVIDE               : 
DO                   : 
DOLLARSIGN           : 
DOT                  : 
DOUBLECOLON          : 
ECHO                 : 38
ELSE                 : 60 61
ELSEIF               : 58 59
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
EQUALS               : 31
EXIT                 : 
EXTENDS              : 
FALSE                : 28
FGETS                : 21
FIXEDARRAY           : 
FLOAT                : 25
FOR                  : 
FOREACH              : 
FORMAT               : 
FUNCTION             : 47
GOTO                 : 
GREATERTHAN          : 32 42
GREATERTHANEQ        : 33
HEAP                 : 
IDENTICAL            : 30
IDENTIFIER           : 16 26 40 41 42 48 49 51 52 54 55
IF                   : 53
INCREMENT            : 
INTDIVIDE            : 
INTEGER              : 24 40
LBRACKET             : 
LESSTHAN             : 34
LESSTHANEQ           : 35
LPAREN               : 17 19 20 21 39 40 41 43 44 45 46 47 50 51 53 58 59
MAXHEAP              : 
MINHEAP              : 
MINUS                : 42
MODULE               : 
NAMEFUNCTION         : 47 50 51
NEW                  : 41
NOTIDENTICAL         : 
OBJECTSTORAGE        : 
OR                   : 37
PLUS                 : 
POP                  : 44
POWERBY              : 
PRINT                : 17 18 19
PRINTF               : 20
PRIORITYQUEUE        : 
PUBLIC               : 
PUSH                 : 43
QUEUE                : 
RBRACKET             : 
RETURN               : 52
RPAREN               : 17 19 20 21 39 40 41 43 44 45 46 47 50 51 53 58 59
SEMICOLON            : 16 17 18 19 20 21 38 40 41 43 44 45 46 50 51 52
SIMPLEARROW          : 
STACK                : 41
STATIC               : 
STRING               : 29 38
SWITCH               : 
TIMES                : 
TRUE                 : 27
TRY                  : 
WHILE                : 39
XOR                  : 
error                : 

Nonterminals, with rules where they appear

array                : 8
assignment           : 3
condition            : 56 57 58 59
conditions           : 39 53 57
echo                 : 7
else                 : 14
elseif               : 13
function             : 5
if                   : 12
input                : 4
op_stack             : 10
operad_stack         : 11 42
operator             : 57
parameter            : 47 49 50 51
print                : 1
printf               : 2
return               : 6
sentence             : 0
sign                 : 55
stack                : 9
value                : 18 22 23 55
values               : 16 17 20 21 23 43
while                : 15

Parsing method: LALR

state 0

    (0) S' -> . sentence
    (1) sentence -> . print
    (2) sentence -> . printf
    (3) sentence -> . assignment
    (4) sentence -> . input
    (5) sentence -> . function
    (6) sentence -> . return
    (7) sentence -> . echo
    (8) sentence -> . array
    (9) sentence -> . stack
    (10) sentence -> . op_stack
    (11) sentence -> . operad_stack
    (12) sentence -> . if
    (13) sentence -> . elseif
    (14) sentence -> . else
    (15) sentence -> . while
    (17) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (18) print -> . PRINT value SEMICOLON
    (19) print -> . PRINT LPAREN RPAREN SEMICOLON
    (20) printf -> . PRINTF LPAREN values RPAREN SEMICOLON
    (16) assignment -> . IDENTIFIER ASSINGMENT values SEMICOLON
    (21) input -> . FGETS LPAREN values RPAREN SEMICOLON
    (47) function -> . FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
    (50) function -> . NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (51) function -> . IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (52) return -> . RETURN IDENTIFIER SEMICOLON
    (38) echo -> . ECHO STRING SEMICOLON
    (40) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (41) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (42) op_stack -> . IDENTIFIER MINUS GREATERTHAN operad_stack
    (43) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (44) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (45) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (46) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON
    (53) if -> . IF LPAREN conditions RPAREN CURLYLEFTBRACKET
    (58) elseif -> . ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (59) elseif -> . CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (60) else -> . ELSE CURLYLEFTBRACKET
    (61) else -> . CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET
    (39) while -> . WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET

    PRINT           shift and go to state 17
    PRINTF          shift and go to state 18
    IDENTIFIER      shift and go to state 19
    FGETS           shift and go to state 20
    FUNCTION        shift and go to state 21
    NAMEFUNCTION    shift and go to state 22
    RETURN          shift and go to state 23
    ECHO            shift and go to state 24
    PUSH            shift and go to state 25
    POP             shift and go to state 26
    COUNT           shift and go to state 27
    CURRENT         shift and go to state 28
    IF              shift and go to state 29
    ELSEIF          shift and go to state 30
    CURLYRIGHTBRACKET shift and go to state 31
    ELSE            shift and go to state 32
    WHILE           shift and go to state 33

    sentence                       shift and go to state 1
    print                          shift and go to state 2
    printf                         shift and go to state 3
    assignment                     shift and go to state 4
    input                          shift and go to state 5
    function                       shift and go to state 6
    return                         shift and go to state 7
    echo                           shift and go to state 8
    array                          shift and go to state 9
    stack                          shift and go to state 10
    op_stack                       shift and go to state 11
    operad_stack                   shift and go to state 12
    if                             shift and go to state 13
    elseif                         shift and go to state 14
    else                           shift and go to state 15
    while                          shift and go to state 16

state 1

    (0) S' -> sentence .



state 2

    (1) sentence -> print .

    $end            reduce using rule 1 (sentence -> print .)


state 3

    (2) sentence -> printf .

    $end            reduce using rule 2 (sentence -> printf .)


state 4

    (3) sentence -> assignment .

    $end            reduce using rule 3 (sentence -> assignment .)


state 5

    (4) sentence -> input .

    $end            reduce using rule 4 (sentence -> input .)


state 6

    (5) sentence -> function .

    $end            reduce using rule 5 (sentence -> function .)


state 7

    (6) sentence -> return .

    $end            reduce using rule 6 (sentence -> return .)


state 8

    (7) sentence -> echo .

    $end            reduce using rule 7 (sentence -> echo .)


state 9

    (8) sentence -> array .

    $end            reduce using rule 8 (sentence -> array .)


state 10

    (9) sentence -> stack .

    $end            reduce using rule 9 (sentence -> stack .)


state 11

    (10) sentence -> op_stack .

    $end            reduce using rule 10 (sentence -> op_stack .)


state 12

    (11) sentence -> operad_stack .

    $end            reduce using rule 11 (sentence -> operad_stack .)


state 13

    (12) sentence -> if .

    $end            reduce using rule 12 (sentence -> if .)


state 14

    (13) sentence -> elseif .

    $end            reduce using rule 13 (sentence -> elseif .)


state 15

    (14) sentence -> else .

    $end            reduce using rule 14 (sentence -> else .)


state 16

    (15) sentence -> while .

    $end            reduce using rule 15 (sentence -> while .)


state 17

    (17) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (18) print -> PRINT . value SEMICOLON
    (19) print -> PRINT . LPAREN RPAREN SEMICOLON
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    LPAREN          shift and go to state 34
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    value                          shift and go to state 35

state 18

    (20) printf -> PRINTF . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 42


state 19

    (16) assignment -> IDENTIFIER . ASSINGMENT values SEMICOLON
    (51) function -> IDENTIFIER . ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (40) array -> IDENTIFIER . ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (41) stack -> IDENTIFIER . ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (42) op_stack -> IDENTIFIER . MINUS GREATERTHAN operad_stack

    ASSINGMENT      shift and go to state 43
    MINUS           shift and go to state 44


state 20

    (21) input -> FGETS . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 45


state 21

    (47) function -> FUNCTION . NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET

    NAMEFUNCTION    shift and go to state 46


state 22

    (50) function -> NAMEFUNCTION . LPAREN parameter RPAREN SEMICOLON

    LPAREN          shift and go to state 47


state 23

    (52) return -> RETURN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 48


state 24

    (38) echo -> ECHO . STRING SEMICOLON

    STRING          shift and go to state 49


state 25

    (43) operad_stack -> PUSH . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 50


state 26

    (44) operad_stack -> POP . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 51


state 27

    (45) operad_stack -> COUNT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 52


state 28

    (46) operad_stack -> CURRENT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 53


state 29

    (53) if -> IF . LPAREN conditions RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 54


state 30

    (58) elseif -> ELSEIF . LPAREN condition RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 55


state 31

    (59) elseif -> CURLYRIGHTBRACKET . ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (61) else -> CURLYRIGHTBRACKET . ELSE CURLYLEFTBRACKET

    ELSEIF          shift and go to state 56
    ELSE            shift and go to state 57


state 32

    (60) else -> ELSE . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 58


state 33

    (39) while -> WHILE . LPAREN conditions RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 59


state 34

    (17) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (19) print -> PRINT LPAREN . RPAREN SEMICOLON
    (22) values -> . value
    (23) values -> . value COMMA values
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    RPAREN          shift and go to state 61
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    values                         shift and go to state 60
    value                          shift and go to state 62

state 35

    (18) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 63


state 36

    (24) value -> INTEGER .

    SEMICOLON       reduce using rule 24 (value -> INTEGER .)
    COMMA           reduce using rule 24 (value -> INTEGER .)
    RPAREN          reduce using rule 24 (value -> INTEGER .)
    AND             reduce using rule 24 (value -> INTEGER .)
    OR              reduce using rule 24 (value -> INTEGER .)


state 37

    (25) value -> FLOAT .

    SEMICOLON       reduce using rule 25 (value -> FLOAT .)
    COMMA           reduce using rule 25 (value -> FLOAT .)
    RPAREN          reduce using rule 25 (value -> FLOAT .)
    AND             reduce using rule 25 (value -> FLOAT .)
    OR              reduce using rule 25 (value -> FLOAT .)


state 38

    (26) value -> IDENTIFIER .

    SEMICOLON       reduce using rule 26 (value -> IDENTIFIER .)
    COMMA           reduce using rule 26 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 26 (value -> IDENTIFIER .)
    AND             reduce using rule 26 (value -> IDENTIFIER .)
    OR              reduce using rule 26 (value -> IDENTIFIER .)


state 39

    (27) value -> TRUE .

    SEMICOLON       reduce using rule 27 (value -> TRUE .)
    COMMA           reduce using rule 27 (value -> TRUE .)
    RPAREN          reduce using rule 27 (value -> TRUE .)
    AND             reduce using rule 27 (value -> TRUE .)
    OR              reduce using rule 27 (value -> TRUE .)


state 40

    (28) value -> FALSE .

    SEMICOLON       reduce using rule 28 (value -> FALSE .)
    COMMA           reduce using rule 28 (value -> FALSE .)
    RPAREN          reduce using rule 28 (value -> FALSE .)
    AND             reduce using rule 28 (value -> FALSE .)
    OR              reduce using rule 28 (value -> FALSE .)


state 41

    (29) value -> STRING .

    SEMICOLON       reduce using rule 29 (value -> STRING .)
    COMMA           reduce using rule 29 (value -> STRING .)
    RPAREN          reduce using rule 29 (value -> STRING .)
    AND             reduce using rule 29 (value -> STRING .)
    OR              reduce using rule 29 (value -> STRING .)


state 42

    (20) printf -> PRINTF LPAREN . values RPAREN SEMICOLON
    (22) values -> . value
    (23) values -> . value COMMA values
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    values                         shift and go to state 64
    value                          shift and go to state 62

state 43

    (16) assignment -> IDENTIFIER ASSINGMENT . values SEMICOLON
    (51) function -> IDENTIFIER ASSINGMENT . NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (40) array -> IDENTIFIER ASSINGMENT . ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (41) stack -> IDENTIFIER ASSINGMENT . NEW STACK LPAREN RPAREN SEMICOLON
    (22) values -> . value
    (23) values -> . value COMMA values
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    NAMEFUNCTION    shift and go to state 66
    ARRAY           shift and go to state 67
    NEW             shift and go to state 68
    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    values                         shift and go to state 65
    value                          shift and go to state 62

state 44

    (42) op_stack -> IDENTIFIER MINUS . GREATERTHAN operad_stack

    GREATERTHAN     shift and go to state 69


state 45

    (21) input -> FGETS LPAREN . values RPAREN SEMICOLON
    (22) values -> . value
    (23) values -> . value COMMA values
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    values                         shift and go to state 70
    value                          shift and go to state 62

state 46

    (47) function -> FUNCTION NAMEFUNCTION . LPAREN parameter RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 71


state 47

    (50) function -> NAMEFUNCTION LPAREN . parameter RPAREN SEMICOLON
    (48) parameter -> . IDENTIFIER
    (49) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 73

    parameter                      shift and go to state 72

state 48

    (52) return -> RETURN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 74


state 49

    (38) echo -> ECHO STRING . SEMICOLON

    SEMICOLON       shift and go to state 75


state 50

    (43) operad_stack -> PUSH LPAREN . values RPAREN SEMICOLON
    (22) values -> . value
    (23) values -> . value COMMA values
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    values                         shift and go to state 76
    value                          shift and go to state 62

state 51

    (44) operad_stack -> POP LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 77


state 52

    (45) operad_stack -> COUNT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 78


state 53

    (46) operad_stack -> CURRENT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 79


state 54

    (53) if -> IF LPAREN . conditions RPAREN CURLYLEFTBRACKET
    (56) conditions -> . condition
    (57) conditions -> . condition operator conditions
    (54) condition -> . IDENTIFIER
    (55) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 82

    conditions                     shift and go to state 80
    condition                      shift and go to state 81

state 55

    (58) elseif -> ELSEIF LPAREN . condition RPAREN CURLYLEFTBRACKET
    (54) condition -> . IDENTIFIER
    (55) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 82

    condition                      shift and go to state 83

state 56

    (59) elseif -> CURLYRIGHTBRACKET ELSEIF . LPAREN condition RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 84


state 57

    (61) else -> CURLYRIGHTBRACKET ELSE . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 85


state 58

    (60) else -> ELSE CURLYLEFTBRACKET .

    $end            reduce using rule 60 (else -> ELSE CURLYLEFTBRACKET .)


state 59

    (39) while -> WHILE LPAREN . conditions RPAREN CURLYLEFTBRACKET
    (56) conditions -> . condition
    (57) conditions -> . condition operator conditions
    (54) condition -> . IDENTIFIER
    (55) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 82

    conditions                     shift and go to state 86
    condition                      shift and go to state 81

state 60

    (17) print -> PRINT LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 87


state 61

    (19) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 88


state 62

    (22) values -> value .
    (23) values -> value . COMMA values

    RPAREN          reduce using rule 22 (values -> value .)
    SEMICOLON       reduce using rule 22 (values -> value .)
    COMMA           shift and go to state 89


state 63

    (18) print -> PRINT value SEMICOLON .

    $end            reduce using rule 18 (print -> PRINT value SEMICOLON .)


state 64

    (20) printf -> PRINTF LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 90


state 65

    (16) assignment -> IDENTIFIER ASSINGMENT values . SEMICOLON

    SEMICOLON       shift and go to state 91


state 66

    (51) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION . LPAREN parameter RPAREN SEMICOLON

    LPAREN          shift and go to state 92


state 67

    (40) array -> IDENTIFIER ASSINGMENT ARRAY . LPAREN INTEGER RPAREN SEMICOLON

    LPAREN          shift and go to state 93


state 68

    (41) stack -> IDENTIFIER ASSINGMENT NEW . STACK LPAREN RPAREN SEMICOLON

    STACK           shift and go to state 94


state 69

    (42) op_stack -> IDENTIFIER MINUS GREATERTHAN . operad_stack
    (43) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (44) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (45) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (46) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON

    PUSH            shift and go to state 25
    POP             shift and go to state 26
    COUNT           shift and go to state 27
    CURRENT         shift and go to state 28

    operad_stack                   shift and go to state 95

state 70

    (21) input -> FGETS LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 96


state 71

    (47) function -> FUNCTION NAMEFUNCTION LPAREN . parameter RPAREN CURLYLEFTBRACKET
    (48) parameter -> . IDENTIFIER
    (49) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 73

    parameter                      shift and go to state 97

state 72

    (50) function -> NAMEFUNCTION LPAREN parameter . RPAREN SEMICOLON

    RPAREN          shift and go to state 98


state 73

    (48) parameter -> IDENTIFIER .
    (49) parameter -> IDENTIFIER . COMMA parameter

    RPAREN          reduce using rule 48 (parameter -> IDENTIFIER .)
    COMMA           shift and go to state 99


state 74

    (52) return -> RETURN IDENTIFIER SEMICOLON .

    $end            reduce using rule 52 (return -> RETURN IDENTIFIER SEMICOLON .)


state 75

    (38) echo -> ECHO STRING SEMICOLON .

    $end            reduce using rule 38 (echo -> ECHO STRING SEMICOLON .)


state 76

    (43) operad_stack -> PUSH LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 100


state 77

    (44) operad_stack -> POP LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 101


state 78

    (45) operad_stack -> COUNT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 102


state 79

    (46) operad_stack -> CURRENT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 103


state 80

    (53) if -> IF LPAREN conditions . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 104


state 81

    (56) conditions -> condition .
    (57) conditions -> condition . operator conditions
    (36) operator -> . AND
    (37) operator -> . OR

    RPAREN          reduce using rule 56 (conditions -> condition .)
    AND             shift and go to state 106
    OR              shift and go to state 107

    operator                       shift and go to state 105

state 82

    (54) condition -> IDENTIFIER .
    (55) condition -> IDENTIFIER . sign value
    (30) sign -> . IDENTICAL
    (31) sign -> . EQUALS
    (32) sign -> . GREATERTHAN
    (33) sign -> . GREATERTHANEQ
    (34) sign -> . LESSTHAN
    (35) sign -> . LESSTHANEQ

    AND             reduce using rule 54 (condition -> IDENTIFIER .)
    OR              reduce using rule 54 (condition -> IDENTIFIER .)
    RPAREN          reduce using rule 54 (condition -> IDENTIFIER .)
    IDENTICAL       shift and go to state 109
    EQUALS          shift and go to state 110
    GREATERTHAN     shift and go to state 111
    GREATERTHANEQ   shift and go to state 112
    LESSTHAN        shift and go to state 113
    LESSTHANEQ      shift and go to state 114

    sign                           shift and go to state 108

state 83

    (58) elseif -> ELSEIF LPAREN condition . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 115


state 84

    (59) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN . condition RPAREN CURLYLEFTBRACKET
    (54) condition -> . IDENTIFIER
    (55) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 82

    condition                      shift and go to state 116

state 85

    (61) else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET .

    $end            reduce using rule 61 (else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET .)


state 86

    (39) while -> WHILE LPAREN conditions . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 117


state 87

    (17) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 118


state 88

    (19) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 19 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 89

    (23) values -> value COMMA . values
    (22) values -> . value
    (23) values -> . value COMMA values
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    value                          shift and go to state 62
    values                         shift and go to state 119

state 90

    (20) printf -> PRINTF LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 120


state 91

    (16) assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .

    $end            reduce using rule 16 (assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .)


state 92

    (51) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN . parameter RPAREN SEMICOLON
    (48) parameter -> . IDENTIFIER
    (49) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 73

    parameter                      shift and go to state 121

state 93

    (40) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN . INTEGER RPAREN SEMICOLON

    INTEGER         shift and go to state 122


state 94

    (41) stack -> IDENTIFIER ASSINGMENT NEW STACK . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 123


state 95

    (42) op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .

    $end            reduce using rule 42 (op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .)


state 96

    (21) input -> FGETS LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 124


state 97

    (47) function -> FUNCTION NAMEFUNCTION LPAREN parameter . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 125


state 98

    (50) function -> NAMEFUNCTION LPAREN parameter RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 126


state 99

    (49) parameter -> IDENTIFIER COMMA . parameter
    (48) parameter -> . IDENTIFIER
    (49) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 73

    parameter                      shift and go to state 127

state 100

    (43) operad_stack -> PUSH LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 128


state 101

    (44) operad_stack -> POP LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 44 (operad_stack -> POP LPAREN RPAREN SEMICOLON .)


state 102

    (45) operad_stack -> COUNT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 45 (operad_stack -> COUNT LPAREN RPAREN SEMICOLON .)


state 103

    (46) operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 46 (operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .)


state 104

    (53) if -> IF LPAREN conditions RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 129


state 105

    (57) conditions -> condition operator . conditions
    (56) conditions -> . condition
    (57) conditions -> . condition operator conditions
    (54) condition -> . IDENTIFIER
    (55) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 82

    condition                      shift and go to state 81
    conditions                     shift and go to state 130

state 106

    (36) operator -> AND .

    IDENTIFIER      reduce using rule 36 (operator -> AND .)


state 107

    (37) operator -> OR .

    IDENTIFIER      reduce using rule 37 (operator -> OR .)


state 108

    (55) condition -> IDENTIFIER sign . value
    (24) value -> . INTEGER
    (25) value -> . FLOAT
    (26) value -> . IDENTIFIER
    (27) value -> . TRUE
    (28) value -> . FALSE
    (29) value -> . STRING

    INTEGER         shift and go to state 36
    FLOAT           shift and go to state 37
    IDENTIFIER      shift and go to state 38
    TRUE            shift and go to state 39
    FALSE           shift and go to state 40
    STRING          shift and go to state 41

    value                          shift and go to state 131

state 109

    (30) sign -> IDENTICAL .

    INTEGER         reduce using rule 30 (sign -> IDENTICAL .)
    FLOAT           reduce using rule 30 (sign -> IDENTICAL .)
    IDENTIFIER      reduce using rule 30 (sign -> IDENTICAL .)
    TRUE            reduce using rule 30 (sign -> IDENTICAL .)
    FALSE           reduce using rule 30 (sign -> IDENTICAL .)
    STRING          reduce using rule 30 (sign -> IDENTICAL .)


state 110

    (31) sign -> EQUALS .

    INTEGER         reduce using rule 31 (sign -> EQUALS .)
    FLOAT           reduce using rule 31 (sign -> EQUALS .)
    IDENTIFIER      reduce using rule 31 (sign -> EQUALS .)
    TRUE            reduce using rule 31 (sign -> EQUALS .)
    FALSE           reduce using rule 31 (sign -> EQUALS .)
    STRING          reduce using rule 31 (sign -> EQUALS .)


state 111

    (32) sign -> GREATERTHAN .

    INTEGER         reduce using rule 32 (sign -> GREATERTHAN .)
    FLOAT           reduce using rule 32 (sign -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 32 (sign -> GREATERTHAN .)
    TRUE            reduce using rule 32 (sign -> GREATERTHAN .)
    FALSE           reduce using rule 32 (sign -> GREATERTHAN .)
    STRING          reduce using rule 32 (sign -> GREATERTHAN .)


state 112

    (33) sign -> GREATERTHANEQ .

    INTEGER         reduce using rule 33 (sign -> GREATERTHANEQ .)
    FLOAT           reduce using rule 33 (sign -> GREATERTHANEQ .)
    IDENTIFIER      reduce using rule 33 (sign -> GREATERTHANEQ .)
    TRUE            reduce using rule 33 (sign -> GREATERTHANEQ .)
    FALSE           reduce using rule 33 (sign -> GREATERTHANEQ .)
    STRING          reduce using rule 33 (sign -> GREATERTHANEQ .)


state 113

    (34) sign -> LESSTHAN .

    INTEGER         reduce using rule 34 (sign -> LESSTHAN .)
    FLOAT           reduce using rule 34 (sign -> LESSTHAN .)
    IDENTIFIER      reduce using rule 34 (sign -> LESSTHAN .)
    TRUE            reduce using rule 34 (sign -> LESSTHAN .)
    FALSE           reduce using rule 34 (sign -> LESSTHAN .)
    STRING          reduce using rule 34 (sign -> LESSTHAN .)


state 114

    (35) sign -> LESSTHANEQ .

    INTEGER         reduce using rule 35 (sign -> LESSTHANEQ .)
    FLOAT           reduce using rule 35 (sign -> LESSTHANEQ .)
    IDENTIFIER      reduce using rule 35 (sign -> LESSTHANEQ .)
    TRUE            reduce using rule 35 (sign -> LESSTHANEQ .)
    FALSE           reduce using rule 35 (sign -> LESSTHANEQ .)
    STRING          reduce using rule 35 (sign -> LESSTHANEQ .)


state 115

    (58) elseif -> ELSEIF LPAREN condition RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 132


state 116

    (59) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 133


state 117

    (39) while -> WHILE LPAREN conditions RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 134


state 118

    (17) print -> PRINT LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 17 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 119

    (23) values -> value COMMA values .

    RPAREN          reduce using rule 23 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 23 (values -> value COMMA values .)


state 120

    (20) printf -> PRINTF LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 20 (printf -> PRINTF LPAREN values RPAREN SEMICOLON .)


state 121

    (51) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter . RPAREN SEMICOLON

    RPAREN          shift and go to state 135


state 122

    (40) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER . RPAREN SEMICOLON

    RPAREN          shift and go to state 136


state 123

    (41) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 137


state 124

    (21) input -> FGETS LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 21 (input -> FGETS LPAREN values RPAREN SEMICOLON .)


state 125

    (47) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 138


state 126

    (50) function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .

    $end            reduce using rule 50 (function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .)


state 127

    (49) parameter -> IDENTIFIER COMMA parameter .

    RPAREN          reduce using rule 49 (parameter -> IDENTIFIER COMMA parameter .)


state 128

    (43) operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 43 (operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .)


state 129

    (53) if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 53 (if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET .)


state 130

    (57) conditions -> condition operator conditions .

    RPAREN          reduce using rule 57 (conditions -> condition operator conditions .)


state 131

    (55) condition -> IDENTIFIER sign value .

    AND             reduce using rule 55 (condition -> IDENTIFIER sign value .)
    OR              reduce using rule 55 (condition -> IDENTIFIER sign value .)
    RPAREN          reduce using rule 55 (condition -> IDENTIFIER sign value .)


state 132

    (58) elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 58 (elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .)


state 133

    (59) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 139


state 134

    (39) while -> WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 39 (while -> WHILE LPAREN conditions RPAREN CURLYLEFTBRACKET .)


state 135

    (51) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 140


state 136

    (40) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 141


state 137

    (41) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 142


state 138

    (47) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 47 (function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .)


state 139

    (59) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 59 (elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .)


state 140

    (51) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .

    $end            reduce using rule 51 (function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .)


state 141

    (40) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .

    $end            reduce using rule 40 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)


state 142

    (41) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 41 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)

