Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ANDEQUAL
    APOSTROPHE
    ATTACH
    BREAK
    CASE
    CATCH
    CLASS
    COLON
    COMMENTS
    CONTAINS
    CONTINUE
    DECLARE
    DECREMENT
    DEFAULT
    DIVIDE
    DOT
    DOUBLECOLON
    ENDFOR
    ENDFOREACH
    ENDIF
    EXTENDS
    FIXEDARRAY
    FOR
    FORMAT
    GOTO
    HEAP
    INCREMENT
    INTDIVIDE
    LBRACKET
    MAXHEAP
    MINHEAP
    MODULE
    NOTIDENTICAL
    OBJECTSTORAGE
    PLUS
    POWERBY
    PRIORITYQUEUE
    PUBLIC
    RBRACKET
    SIMPLEARROW
    STATIC
    SWITCH
    TIMES
    TRY
    WHILE
    XOR

Grammar

Rule 0     S' -> sentence
Rule 1     sentence -> print
Rule 2     sentence -> printf
Rule 3     sentence -> assignment
Rule 4     sentence -> input
Rule 5     sentence -> function
Rule 6     sentence -> return
Rule 7     sentence -> echo
Rule 8     sentence -> array
Rule 9     sentence -> stack
Rule 10    sentence -> op_stack
Rule 11    sentence -> operad_stack
Rule 12    sentence -> if
Rule 13    sentence -> elseif
Rule 14    sentence -> else
Rule 15    sentence -> do
Rule 16    sentence -> die
Rule 17    sentence -> exit
Rule 18    sentence -> foreach
Rule 19    assignment -> IDENTIFIER ASSINGMENT values SEMICOLON
Rule 20    print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 21    print -> PRINT value SEMICOLON
Rule 22    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 23    printf -> PRINTF LPAREN values RPAREN SEMICOLON
Rule 24    input -> FGETS LPAREN values RPAREN SEMICOLON
Rule 25    values -> value
Rule 26    values -> value COMMA values
Rule 27    value -> INTEGER
Rule 28    value -> FLOAT
Rule 29    value -> IDENTIFIER
Rule 30    value -> TRUE
Rule 31    value -> FALSE
Rule 32    value -> STRING
Rule 33    item -> value
Rule 34    item -> stack
Rule 35    item -> array
Rule 36    item -> queue
Rule 37    sign -> IDENTICAL
Rule 38    sign -> EQUALS
Rule 39    sign -> GREATERTHAN
Rule 40    sign -> GREATERTHANEQ
Rule 41    sign -> LESSTHAN
Rule 42    sign -> LESSTHANEQ
Rule 43    operator -> AND
Rule 44    operator -> OR
Rule 45    echo -> ECHO STRING SEMICOLON
Rule 46    array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
Rule 47    items -> item repite_items
Rule 48    repite_items -> COMMA item
Rule 49    repite_items -> COMMA item repite_items
Rule 50    array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
Rule 51    array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
Rule 52    itemsARROW -> item ARROW item repite_items_f
Rule 53    repite_items_f -> COMMA item ARROW item
Rule 54    repite_items_f -> COMMA item ARROW item repite_items
Rule 55    array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
Rule 56    queue -> NEW QUEUE LPAREN RPAREN
Rule 57    stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
Rule 58    op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack
Rule 59    operad_stack -> PUSH LPAREN values RPAREN SEMICOLON
Rule 60    operad_stack -> POP LPAREN RPAREN SEMICOLON
Rule 61    operad_stack -> COUNT LPAREN RPAREN SEMICOLON
Rule 62    operad_stack -> CURRENT LPAREN RPAREN SEMICOLON
Rule 63    function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
Rule 64    parameter -> IDENTIFIER
Rule 65    parameter -> IDENTIFIER COMMA parameter
Rule 66    function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
Rule 67    function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
Rule 68    return -> RETURN IDENTIFIER SEMICOLON
Rule 69    if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET
Rule 70    condition -> IDENTIFIER
Rule 71    condition -> IDENTIFIER sign value
Rule 72    conditions -> condition
Rule 73    conditions -> condition operator conditions
Rule 74    elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
Rule 75    elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
Rule 76    else -> ELSE CURLYLEFTBRACKET
Rule 77    else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET
Rule 78    do -> DO CURLYLEFTBRACKET
Rule 79    die -> DIE LPAREN STRING RPAREN SEMICOLON
Rule 80    exit -> EXIT LPAREN STRING RPAREN SEMICOLON
Rule 81    foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

Terminals, with rules where they appear

AND                  : 43
ANDEQUAL             : 
APOSTROPHE           : 
ARRAY                : 46 50 51 55
ARROW                : 50 52 53 54
ASSINGMENT           : 19 46 50 51 55 57 67
ATTACH               : 
BREAK                : 
CASE                 : 
CATCH                : 
CHAIN                : 50 51 55 81
CLASS                : 
COLON                : 
COMMA                : 26 48 49 53 54 65
COMMENTS             : 
CONTAINS             : 
CONTINUE             : 
COUNT                : 61
CURLYLEFTBRACKET     : 63 69 74 75 76 77 78 81
CURLYRIGHTBRACKET    : 75 77
CURRENT              : 62
DECLARE              : 
DECREMENT            : 
DEFAULT              : 
DIE                  : 79
DIVIDE               : 
DO                   : 78
DOLLARSIGN           : 50 51 55
DOT                  : 
DOUBLECOLON          : 
ECHO                 : 45
ELSE                 : 76 77
ELSEIF               : 74 75
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
EQUALS               : 38
EXIT                 : 80
EXTENDS              : 
FALSE                : 31
FGETS                : 24
FIXEDARRAY           : 
FLOAT                : 28
FOR                  : 
FOREACH              : 81
FORMAT               : 
FUNCTION             : 63
GOTO                 : 
GREATERTHAN          : 39 58
GREATERTHANEQ        : 40
HEAP                 : 
IDENTICAL            : 37
IDENTIFIER           : 19 29 46 57 58 64 65 67 68 70 71 81 81
IF                   : 69
INCREMENT            : 
INTDIVIDE            : 
INTEGER              : 27 46
LBRACKET             : 
LESSTHAN             : 41
LESSTHANEQ           : 42
LPAREN               : 20 22 23 24 46 50 51 55 56 57 59 60 61 62 63 66 67 69 74 75 79 80 81
MAXHEAP              : 
MINHEAP              : 
MINUS                : 58
MODULE               : 
NAMEFUNCTION         : 63 66 67
NEW                  : 56 57
NOTIDENTICAL         : 
OBJECTSTORAGE        : 
OR                   : 44
PLUS                 : 
POP                  : 60
POWERBY              : 
PRINT                : 20 21 22
PRINTF               : 23
PRIORITYQUEUE        : 
PUBLIC               : 
PUSH                 : 59
QUEUE                : 56
RBRACKET             : 
RETURN               : 68
RPAREN               : 20 22 23 24 46 50 51 55 56 57 59 60 61 62 63 66 67 69 74 75 79 80 81
SEMICOLON            : 19 20 21 22 23 24 45 46 50 51 55 57 59 60 61 62 66 67 68 79 80
SIMPLEARROW          : 
STACK                : 57
STATIC               : 
STRING               : 32 45 79 80
SWITCH               : 
TIMES                : 
TRUE                 : 30
TRY                  : 
WHILE                : 
XOR                  : 
error                : 

Nonterminals, with rules where they appear

array                : 8 35
assignment           : 3
condition            : 72 73 74 75
conditions           : 69 73
die                  : 16
do                   : 15
echo                 : 7
else                 : 14
elseif               : 13
exit                 : 17
foreach              : 18
function             : 5
if                   : 12
input                : 4
item                 : 47 48 49 50 50 52 52 53 53 54 54
items                : 51
itemsARROW           : 55
op_stack             : 10
operad_stack         : 11 58
operator             : 73
parameter            : 63 65 66 67
print                : 1
printf               : 2
queue                : 36
repite_items         : 47 49 54
repite_items_f       : 52
return               : 6
sentence             : 0
sign                 : 71
stack                : 9 34
value                : 21 25 26 33 71
values               : 19 20 23 24 26 59

Parsing method: LALR

state 0

    (0) S' -> . sentence
    (1) sentence -> . print
    (2) sentence -> . printf
    (3) sentence -> . assignment
    (4) sentence -> . input
    (5) sentence -> . function
    (6) sentence -> . return
    (7) sentence -> . echo
    (8) sentence -> . array
    (9) sentence -> . stack
    (10) sentence -> . op_stack
    (11) sentence -> . operad_stack
    (12) sentence -> . if
    (13) sentence -> . elseif
    (14) sentence -> . else
    (15) sentence -> . do
    (16) sentence -> . die
    (17) sentence -> . exit
    (18) sentence -> . foreach
    (20) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (21) print -> . PRINT value SEMICOLON
    (22) print -> . PRINT LPAREN RPAREN SEMICOLON
    (23) printf -> . PRINTF LPAREN values RPAREN SEMICOLON
    (19) assignment -> . IDENTIFIER ASSINGMENT values SEMICOLON
    (24) input -> . FGETS LPAREN values RPAREN SEMICOLON
    (63) function -> . FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
    (66) function -> . NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (67) function -> . IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (68) return -> . RETURN IDENTIFIER SEMICOLON
    (45) echo -> . ECHO STRING SEMICOLON
    (46) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (50) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (57) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (58) op_stack -> . IDENTIFIER MINUS GREATERTHAN operad_stack
    (59) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (60) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (61) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (62) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON
    (69) if -> . IF LPAREN conditions RPAREN CURLYLEFTBRACKET
    (74) elseif -> . ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (75) elseif -> . CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (76) else -> . ELSE CURLYLEFTBRACKET
    (77) else -> . CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET
    (78) do -> . DO CURLYLEFTBRACKET
    (79) die -> . DIE LPAREN STRING RPAREN SEMICOLON
    (80) exit -> . EXIT LPAREN STRING RPAREN SEMICOLON
    (81) foreach -> . FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

    PRINT           shift and go to state 20
    PRINTF          shift and go to state 21
    IDENTIFIER      shift and go to state 22
    FGETS           shift and go to state 23
    FUNCTION        shift and go to state 24
    NAMEFUNCTION    shift and go to state 25
    RETURN          shift and go to state 26
    ECHO            shift and go to state 27
    DOLLARSIGN      shift and go to state 28
    PUSH            shift and go to state 29
    POP             shift and go to state 30
    COUNT           shift and go to state 31
    CURRENT         shift and go to state 32
    IF              shift and go to state 33
    ELSEIF          shift and go to state 34
    CURLYRIGHTBRACKET shift and go to state 35
    ELSE            shift and go to state 36
    DO              shift and go to state 37
    DIE             shift and go to state 38
    EXIT            shift and go to state 39
    FOREACH         shift and go to state 40

    sentence                       shift and go to state 1
    print                          shift and go to state 2
    printf                         shift and go to state 3
    assignment                     shift and go to state 4
    input                          shift and go to state 5
    function                       shift and go to state 6
    return                         shift and go to state 7
    echo                           shift and go to state 8
    array                          shift and go to state 9
    stack                          shift and go to state 10
    op_stack                       shift and go to state 11
    operad_stack                   shift and go to state 12
    if                             shift and go to state 13
    elseif                         shift and go to state 14
    else                           shift and go to state 15
    do                             shift and go to state 16
    die                            shift and go to state 17
    exit                           shift and go to state 18
    foreach                        shift and go to state 19

state 1

    (0) S' -> sentence .



state 2

    (1) sentence -> print .

    $end            reduce using rule 1 (sentence -> print .)


state 3

    (2) sentence -> printf .

    $end            reduce using rule 2 (sentence -> printf .)


state 4

    (3) sentence -> assignment .

    $end            reduce using rule 3 (sentence -> assignment .)


state 5

    (4) sentence -> input .

    $end            reduce using rule 4 (sentence -> input .)


state 6

    (5) sentence -> function .

    $end            reduce using rule 5 (sentence -> function .)


state 7

    (6) sentence -> return .

    $end            reduce using rule 6 (sentence -> return .)


state 8

    (7) sentence -> echo .

    $end            reduce using rule 7 (sentence -> echo .)


state 9

    (8) sentence -> array .

    $end            reduce using rule 8 (sentence -> array .)


state 10

    (9) sentence -> stack .

    $end            reduce using rule 9 (sentence -> stack .)


state 11

    (10) sentence -> op_stack .

    $end            reduce using rule 10 (sentence -> op_stack .)


state 12

    (11) sentence -> operad_stack .

    $end            reduce using rule 11 (sentence -> operad_stack .)


state 13

    (12) sentence -> if .

    $end            reduce using rule 12 (sentence -> if .)


state 14

    (13) sentence -> elseif .

    $end            reduce using rule 13 (sentence -> elseif .)


state 15

    (14) sentence -> else .

    $end            reduce using rule 14 (sentence -> else .)


state 16

    (15) sentence -> do .

    $end            reduce using rule 15 (sentence -> do .)


state 17

    (16) sentence -> die .

    $end            reduce using rule 16 (sentence -> die .)


state 18

    (17) sentence -> exit .

    $end            reduce using rule 17 (sentence -> exit .)


state 19

    (18) sentence -> foreach .

    $end            reduce using rule 18 (sentence -> foreach .)


state 20

    (20) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (21) print -> PRINT . value SEMICOLON
    (22) print -> PRINT . LPAREN RPAREN SEMICOLON
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    LPAREN          shift and go to state 41
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    value                          shift and go to state 42

state 21

    (23) printf -> PRINTF . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 49


state 22

    (19) assignment -> IDENTIFIER . ASSINGMENT values SEMICOLON
    (67) function -> IDENTIFIER . ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (46) array -> IDENTIFIER . ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (57) stack -> IDENTIFIER . ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (58) op_stack -> IDENTIFIER . MINUS GREATERTHAN operad_stack

    ASSINGMENT      shift and go to state 50
    MINUS           shift and go to state 51


state 23

    (24) input -> FGETS . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 52


state 24

    (63) function -> FUNCTION . NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET

    NAMEFUNCTION    shift and go to state 53


state 25

    (66) function -> NAMEFUNCTION . LPAREN parameter RPAREN SEMICOLON

    LPAREN          shift and go to state 54


state 26

    (68) return -> RETURN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 55


state 27

    (45) echo -> ECHO . STRING SEMICOLON

    STRING          shift and go to state 56


state 28

    (50) array -> DOLLARSIGN . CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> DOLLARSIGN . CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> DOLLARSIGN . CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON

    CHAIN           shift and go to state 57


state 29

    (59) operad_stack -> PUSH . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 58


state 30

    (60) operad_stack -> POP . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 59


state 31

    (61) operad_stack -> COUNT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 60


state 32

    (62) operad_stack -> CURRENT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 61


state 33

    (69) if -> IF . LPAREN conditions RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 62


state 34

    (74) elseif -> ELSEIF . LPAREN condition RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 63


state 35

    (75) elseif -> CURLYRIGHTBRACKET . ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET
    (77) else -> CURLYRIGHTBRACKET . ELSE CURLYLEFTBRACKET

    ELSEIF          shift and go to state 64
    ELSE            shift and go to state 65


state 36

    (76) else -> ELSE . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 66


state 37

    (78) do -> DO . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 67


state 38

    (79) die -> DIE . LPAREN STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 68


state 39

    (80) exit -> EXIT . LPAREN STRING RPAREN SEMICOLON

    LPAREN          shift and go to state 69


state 40

    (81) foreach -> FOREACH . LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 70


state 41

    (20) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (22) print -> PRINT LPAREN . RPAREN SEMICOLON
    (25) values -> . value
    (26) values -> . value COMMA values
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    RPAREN          shift and go to state 72
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    values                         shift and go to state 71
    value                          shift and go to state 73

state 42

    (21) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 74


state 43

    (27) value -> INTEGER .

    SEMICOLON       reduce using rule 27 (value -> INTEGER .)
    COMMA           reduce using rule 27 (value -> INTEGER .)
    RPAREN          reduce using rule 27 (value -> INTEGER .)
    AND             reduce using rule 27 (value -> INTEGER .)
    OR              reduce using rule 27 (value -> INTEGER .)
    ARROW           reduce using rule 27 (value -> INTEGER .)


state 44

    (28) value -> FLOAT .

    SEMICOLON       reduce using rule 28 (value -> FLOAT .)
    COMMA           reduce using rule 28 (value -> FLOAT .)
    RPAREN          reduce using rule 28 (value -> FLOAT .)
    AND             reduce using rule 28 (value -> FLOAT .)
    OR              reduce using rule 28 (value -> FLOAT .)
    ARROW           reduce using rule 28 (value -> FLOAT .)


state 45

    (29) value -> IDENTIFIER .

    SEMICOLON       reduce using rule 29 (value -> IDENTIFIER .)
    COMMA           reduce using rule 29 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 29 (value -> IDENTIFIER .)
    AND             reduce using rule 29 (value -> IDENTIFIER .)
    OR              reduce using rule 29 (value -> IDENTIFIER .)


state 46

    (30) value -> TRUE .

    SEMICOLON       reduce using rule 30 (value -> TRUE .)
    COMMA           reduce using rule 30 (value -> TRUE .)
    RPAREN          reduce using rule 30 (value -> TRUE .)
    AND             reduce using rule 30 (value -> TRUE .)
    OR              reduce using rule 30 (value -> TRUE .)
    ARROW           reduce using rule 30 (value -> TRUE .)


state 47

    (31) value -> FALSE .

    SEMICOLON       reduce using rule 31 (value -> FALSE .)
    COMMA           reduce using rule 31 (value -> FALSE .)
    RPAREN          reduce using rule 31 (value -> FALSE .)
    AND             reduce using rule 31 (value -> FALSE .)
    OR              reduce using rule 31 (value -> FALSE .)
    ARROW           reduce using rule 31 (value -> FALSE .)


state 48

    (32) value -> STRING .

    SEMICOLON       reduce using rule 32 (value -> STRING .)
    COMMA           reduce using rule 32 (value -> STRING .)
    RPAREN          reduce using rule 32 (value -> STRING .)
    AND             reduce using rule 32 (value -> STRING .)
    OR              reduce using rule 32 (value -> STRING .)
    ARROW           reduce using rule 32 (value -> STRING .)


state 49

    (23) printf -> PRINTF LPAREN . values RPAREN SEMICOLON
    (25) values -> . value
    (26) values -> . value COMMA values
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    values                         shift and go to state 75
    value                          shift and go to state 73

state 50

    (19) assignment -> IDENTIFIER ASSINGMENT . values SEMICOLON
    (67) function -> IDENTIFIER ASSINGMENT . NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON
    (46) array -> IDENTIFIER ASSINGMENT . ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (57) stack -> IDENTIFIER ASSINGMENT . NEW STACK LPAREN RPAREN SEMICOLON
    (25) values -> . value
    (26) values -> . value COMMA values
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    NAMEFUNCTION    shift and go to state 77
    ARRAY           shift and go to state 78
    NEW             shift and go to state 79
    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    values                         shift and go to state 76
    value                          shift and go to state 73

state 51

    (58) op_stack -> IDENTIFIER MINUS . GREATERTHAN operad_stack

    GREATERTHAN     shift and go to state 80


state 52

    (24) input -> FGETS LPAREN . values RPAREN SEMICOLON
    (25) values -> . value
    (26) values -> . value COMMA values
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    values                         shift and go to state 81
    value                          shift and go to state 73

state 53

    (63) function -> FUNCTION NAMEFUNCTION . LPAREN parameter RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 82


state 54

    (66) function -> NAMEFUNCTION LPAREN . parameter RPAREN SEMICOLON
    (64) parameter -> . IDENTIFIER
    (65) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 84

    parameter                      shift and go to state 83

state 55

    (68) return -> RETURN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 85


state 56

    (45) echo -> ECHO STRING . SEMICOLON

    SEMICOLON       shift and go to state 86


state 57

    (50) array -> DOLLARSIGN CHAIN . ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> DOLLARSIGN CHAIN . ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> DOLLARSIGN CHAIN . ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON

    ASSINGMENT      shift and go to state 87


state 58

    (59) operad_stack -> PUSH LPAREN . values RPAREN SEMICOLON
    (25) values -> . value
    (26) values -> . value COMMA values
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    values                         shift and go to state 88
    value                          shift and go to state 73

state 59

    (60) operad_stack -> POP LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 89


state 60

    (61) operad_stack -> COUNT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 90


state 61

    (62) operad_stack -> CURRENT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 91


state 62

    (69) if -> IF LPAREN . conditions RPAREN CURLYLEFTBRACKET
    (72) conditions -> . condition
    (73) conditions -> . condition operator conditions
    (70) condition -> . IDENTIFIER
    (71) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 94

    conditions                     shift and go to state 92
    condition                      shift and go to state 93

state 63

    (74) elseif -> ELSEIF LPAREN . condition RPAREN CURLYLEFTBRACKET
    (70) condition -> . IDENTIFIER
    (71) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 94

    condition                      shift and go to state 95

state 64

    (75) elseif -> CURLYRIGHTBRACKET ELSEIF . LPAREN condition RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 96


state 65

    (77) else -> CURLYRIGHTBRACKET ELSE . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 97


state 66

    (76) else -> ELSE CURLYLEFTBRACKET .

    $end            reduce using rule 76 (else -> ELSE CURLYLEFTBRACKET .)


state 67

    (78) do -> DO CURLYLEFTBRACKET .

    $end            reduce using rule 78 (do -> DO CURLYLEFTBRACKET .)


state 68

    (79) die -> DIE LPAREN . STRING RPAREN SEMICOLON

    STRING          shift and go to state 98


state 69

    (80) exit -> EXIT LPAREN . STRING RPAREN SEMICOLON

    STRING          shift and go to state 99


state 70

    (81) foreach -> FOREACH LPAREN . IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

    IDENTIFIER      shift and go to state 100


state 71

    (20) print -> PRINT LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 101


state 72

    (22) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 102


state 73

    (25) values -> value .
    (26) values -> value . COMMA values

    RPAREN          reduce using rule 25 (values -> value .)
    SEMICOLON       reduce using rule 25 (values -> value .)
    COMMA           shift and go to state 103


state 74

    (21) print -> PRINT value SEMICOLON .

    $end            reduce using rule 21 (print -> PRINT value SEMICOLON .)


state 75

    (23) printf -> PRINTF LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 104


state 76

    (19) assignment -> IDENTIFIER ASSINGMENT values . SEMICOLON

    SEMICOLON       shift and go to state 105


state 77

    (67) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION . LPAREN parameter RPAREN SEMICOLON

    LPAREN          shift and go to state 106


state 78

    (46) array -> IDENTIFIER ASSINGMENT ARRAY . LPAREN INTEGER RPAREN SEMICOLON

    LPAREN          shift and go to state 107


state 79

    (57) stack -> IDENTIFIER ASSINGMENT NEW . STACK LPAREN RPAREN SEMICOLON

    STACK           shift and go to state 108


state 80

    (58) op_stack -> IDENTIFIER MINUS GREATERTHAN . operad_stack
    (59) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (60) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (61) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (62) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON

    PUSH            shift and go to state 29
    POP             shift and go to state 30
    COUNT           shift and go to state 31
    CURRENT         shift and go to state 32

    operad_stack                   shift and go to state 109

state 81

    (24) input -> FGETS LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 110


state 82

    (63) function -> FUNCTION NAMEFUNCTION LPAREN . parameter RPAREN CURLYLEFTBRACKET
    (64) parameter -> . IDENTIFIER
    (65) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 84

    parameter                      shift and go to state 111

state 83

    (66) function -> NAMEFUNCTION LPAREN parameter . RPAREN SEMICOLON

    RPAREN          shift and go to state 112


state 84

    (64) parameter -> IDENTIFIER .
    (65) parameter -> IDENTIFIER . COMMA parameter

    RPAREN          reduce using rule 64 (parameter -> IDENTIFIER .)
    COMMA           shift and go to state 113


state 85

    (68) return -> RETURN IDENTIFIER SEMICOLON .

    $end            reduce using rule 68 (return -> RETURN IDENTIFIER SEMICOLON .)


state 86

    (45) echo -> ECHO STRING SEMICOLON .

    $end            reduce using rule 45 (echo -> ECHO STRING SEMICOLON .)


state 87

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT . ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> DOLLARSIGN CHAIN ASSINGMENT . ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> DOLLARSIGN CHAIN ASSINGMENT . ARRAY LPAREN itemsARROW RPAREN SEMICOLON

    ARRAY           shift and go to state 114


state 88

    (59) operad_stack -> PUSH LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 115


state 89

    (60) operad_stack -> POP LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 116


state 90

    (61) operad_stack -> COUNT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 117


state 91

    (62) operad_stack -> CURRENT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 118


state 92

    (69) if -> IF LPAREN conditions . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 119


state 93

    (72) conditions -> condition .
    (73) conditions -> condition . operator conditions
    (43) operator -> . AND
    (44) operator -> . OR

    RPAREN          reduce using rule 72 (conditions -> condition .)
    AND             shift and go to state 121
    OR              shift and go to state 122

    operator                       shift and go to state 120

state 94

    (70) condition -> IDENTIFIER .
    (71) condition -> IDENTIFIER . sign value
    (37) sign -> . IDENTICAL
    (38) sign -> . EQUALS
    (39) sign -> . GREATERTHAN
    (40) sign -> . GREATERTHANEQ
    (41) sign -> . LESSTHAN
    (42) sign -> . LESSTHANEQ

    AND             reduce using rule 70 (condition -> IDENTIFIER .)
    OR              reduce using rule 70 (condition -> IDENTIFIER .)
    RPAREN          reduce using rule 70 (condition -> IDENTIFIER .)
    IDENTICAL       shift and go to state 124
    EQUALS          shift and go to state 125
    GREATERTHAN     shift and go to state 126
    GREATERTHANEQ   shift and go to state 127
    LESSTHAN        shift and go to state 128
    LESSTHANEQ      shift and go to state 129

    sign                           shift and go to state 123

state 95

    (74) elseif -> ELSEIF LPAREN condition . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 130


state 96

    (75) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN . condition RPAREN CURLYLEFTBRACKET
    (70) condition -> . IDENTIFIER
    (71) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 94

    condition                      shift and go to state 131

state 97

    (77) else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET .

    $end            reduce using rule 77 (else -> CURLYRIGHTBRACKET ELSE CURLYLEFTBRACKET .)


state 98

    (79) die -> DIE LPAREN STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 132


state 99

    (80) exit -> EXIT LPAREN STRING . RPAREN SEMICOLON

    RPAREN          shift and go to state 133


state 100

    (81) foreach -> FOREACH LPAREN IDENTIFIER . CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET

    CHAIN           shift and go to state 134


state 101

    (20) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 135


state 102

    (22) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 22 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 103

    (26) values -> value COMMA . values
    (25) values -> . value
    (26) values -> . value COMMA values
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    value                          shift and go to state 73
    values                         shift and go to state 136

state 104

    (23) printf -> PRINTF LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 137


state 105

    (19) assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .

    $end            reduce using rule 19 (assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .)


state 106

    (67) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN . parameter RPAREN SEMICOLON
    (64) parameter -> . IDENTIFIER
    (65) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 84

    parameter                      shift and go to state 138

state 107

    (46) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN . INTEGER RPAREN SEMICOLON

    INTEGER         shift and go to state 139


state 108

    (57) stack -> IDENTIFIER ASSINGMENT NEW STACK . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 140


state 109

    (58) op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .

    $end            reduce using rule 58 (op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .)


state 110

    (24) input -> FGETS LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 141


state 111

    (63) function -> FUNCTION NAMEFUNCTION LPAREN parameter . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 142


state 112

    (66) function -> NAMEFUNCTION LPAREN parameter RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 143


state 113

    (65) parameter -> IDENTIFIER COMMA . parameter
    (64) parameter -> . IDENTIFIER
    (65) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 84

    parameter                      shift and go to state 144

state 114

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY . LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY . LPAREN items RPAREN SEMICOLON
    (55) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY . LPAREN itemsARROW RPAREN SEMICOLON

    LPAREN          shift and go to state 145


state 115

    (59) operad_stack -> PUSH LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 146


state 116

    (60) operad_stack -> POP LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 60 (operad_stack -> POP LPAREN RPAREN SEMICOLON .)


state 117

    (61) operad_stack -> COUNT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 61 (operad_stack -> COUNT LPAREN RPAREN SEMICOLON .)


state 118

    (62) operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 62 (operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .)


state 119

    (69) if -> IF LPAREN conditions RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 147


state 120

    (73) conditions -> condition operator . conditions
    (72) conditions -> . condition
    (73) conditions -> . condition operator conditions
    (70) condition -> . IDENTIFIER
    (71) condition -> . IDENTIFIER sign value

    IDENTIFIER      shift and go to state 94

    condition                      shift and go to state 93
    conditions                     shift and go to state 148

state 121

    (43) operator -> AND .

    IDENTIFIER      reduce using rule 43 (operator -> AND .)


state 122

    (44) operator -> OR .

    IDENTIFIER      reduce using rule 44 (operator -> OR .)


state 123

    (71) condition -> IDENTIFIER sign . value
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 45
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48

    value                          shift and go to state 149

state 124

    (37) sign -> IDENTICAL .

    INTEGER         reduce using rule 37 (sign -> IDENTICAL .)
    FLOAT           reduce using rule 37 (sign -> IDENTICAL .)
    IDENTIFIER      reduce using rule 37 (sign -> IDENTICAL .)
    TRUE            reduce using rule 37 (sign -> IDENTICAL .)
    FALSE           reduce using rule 37 (sign -> IDENTICAL .)
    STRING          reduce using rule 37 (sign -> IDENTICAL .)


state 125

    (38) sign -> EQUALS .

    INTEGER         reduce using rule 38 (sign -> EQUALS .)
    FLOAT           reduce using rule 38 (sign -> EQUALS .)
    IDENTIFIER      reduce using rule 38 (sign -> EQUALS .)
    TRUE            reduce using rule 38 (sign -> EQUALS .)
    FALSE           reduce using rule 38 (sign -> EQUALS .)
    STRING          reduce using rule 38 (sign -> EQUALS .)


state 126

    (39) sign -> GREATERTHAN .

    INTEGER         reduce using rule 39 (sign -> GREATERTHAN .)
    FLOAT           reduce using rule 39 (sign -> GREATERTHAN .)
    IDENTIFIER      reduce using rule 39 (sign -> GREATERTHAN .)
    TRUE            reduce using rule 39 (sign -> GREATERTHAN .)
    FALSE           reduce using rule 39 (sign -> GREATERTHAN .)
    STRING          reduce using rule 39 (sign -> GREATERTHAN .)


state 127

    (40) sign -> GREATERTHANEQ .

    INTEGER         reduce using rule 40 (sign -> GREATERTHANEQ .)
    FLOAT           reduce using rule 40 (sign -> GREATERTHANEQ .)
    IDENTIFIER      reduce using rule 40 (sign -> GREATERTHANEQ .)
    TRUE            reduce using rule 40 (sign -> GREATERTHANEQ .)
    FALSE           reduce using rule 40 (sign -> GREATERTHANEQ .)
    STRING          reduce using rule 40 (sign -> GREATERTHANEQ .)


state 128

    (41) sign -> LESSTHAN .

    INTEGER         reduce using rule 41 (sign -> LESSTHAN .)
    FLOAT           reduce using rule 41 (sign -> LESSTHAN .)
    IDENTIFIER      reduce using rule 41 (sign -> LESSTHAN .)
    TRUE            reduce using rule 41 (sign -> LESSTHAN .)
    FALSE           reduce using rule 41 (sign -> LESSTHAN .)
    STRING          reduce using rule 41 (sign -> LESSTHAN .)


state 129

    (42) sign -> LESSTHANEQ .

    INTEGER         reduce using rule 42 (sign -> LESSTHANEQ .)
    FLOAT           reduce using rule 42 (sign -> LESSTHANEQ .)
    IDENTIFIER      reduce using rule 42 (sign -> LESSTHANEQ .)
    TRUE            reduce using rule 42 (sign -> LESSTHANEQ .)
    FALSE           reduce using rule 42 (sign -> LESSTHANEQ .)
    STRING          reduce using rule 42 (sign -> LESSTHANEQ .)


state 130

    (74) elseif -> ELSEIF LPAREN condition RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 150


state 131

    (75) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 151


state 132

    (79) die -> DIE LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 152


state 133

    (80) exit -> EXIT LPAREN STRING RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 153


state 134

    (81) foreach -> FOREACH LPAREN IDENTIFIER CHAIN . IDENTIFIER RPAREN CURLYLEFTBRACKET

    IDENTIFIER      shift and go to state 154


state 135

    (20) print -> PRINT LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 20 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 136

    (26) values -> value COMMA values .

    RPAREN          reduce using rule 26 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 26 (values -> value COMMA values .)


state 137

    (23) printf -> PRINTF LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 23 (printf -> PRINTF LPAREN values RPAREN SEMICOLON .)


state 138

    (67) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter . RPAREN SEMICOLON

    RPAREN          shift and go to state 155


state 139

    (46) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER . RPAREN SEMICOLON

    RPAREN          shift and go to state 156


state 140

    (57) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 157


state 141

    (24) input -> FGETS LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 24 (input -> FGETS LPAREN values RPAREN SEMICOLON .)


state 142

    (63) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 158


state 143

    (66) function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .

    $end            reduce using rule 66 (function -> NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .)


state 144

    (65) parameter -> IDENTIFIER COMMA parameter .

    RPAREN          reduce using rule 65 (parameter -> IDENTIFIER COMMA parameter .)


state 145

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN . item ARROW item RPAREN SEMICOLON
    (51) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN . items RPAREN SEMICOLON
    (55) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN . itemsARROW RPAREN SEMICOLON
    (33) item -> . value
    (34) item -> . stack
    (35) item -> . array
    (36) item -> . queue
    (47) items -> . item repite_items
    (52) itemsARROW -> . item ARROW item repite_items_f
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING
    (57) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (46) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (50) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (56) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 166
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48
    DOLLARSIGN      shift and go to state 28
    NEW             shift and go to state 167

    item                           shift and go to state 159
    items                          shift and go to state 160
    itemsARROW                     shift and go to state 161
    value                          shift and go to state 162
    stack                          shift and go to state 163
    array                          shift and go to state 164
    queue                          shift and go to state 165

state 146

    (59) operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 59 (operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .)


state 147

    (69) if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 69 (if -> IF LPAREN conditions RPAREN CURLYLEFTBRACKET .)


state 148

    (73) conditions -> condition operator conditions .

    RPAREN          reduce using rule 73 (conditions -> condition operator conditions .)


state 149

    (71) condition -> IDENTIFIER sign value .

    AND             reduce using rule 71 (condition -> IDENTIFIER sign value .)
    OR              reduce using rule 71 (condition -> IDENTIFIER sign value .)
    RPAREN          reduce using rule 71 (condition -> IDENTIFIER sign value .)


state 150

    (74) elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 74 (elseif -> ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .)


state 151

    (75) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 168


state 152

    (79) die -> DIE LPAREN STRING RPAREN SEMICOLON .

    $end            reduce using rule 79 (die -> DIE LPAREN STRING RPAREN SEMICOLON .)


state 153

    (80) exit -> EXIT LPAREN STRING RPAREN SEMICOLON .

    $end            reduce using rule 80 (exit -> EXIT LPAREN STRING RPAREN SEMICOLON .)


state 154

    (81) foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 169


state 155

    (67) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 170


state 156

    (46) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 171


state 157

    (57) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 172


state 158

    (63) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 63 (function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .)


state 159

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item . ARROW item RPAREN SEMICOLON
    (47) items -> item . repite_items
    (52) itemsARROW -> item . ARROW item repite_items_f
    (48) repite_items -> . COMMA item
    (49) repite_items -> . COMMA item repite_items

    ARROW           shift and go to state 173
    COMMA           shift and go to state 175

    repite_items                   shift and go to state 174

state 160

    (51) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items . RPAREN SEMICOLON

    RPAREN          shift and go to state 176


state 161

    (55) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW . RPAREN SEMICOLON

    RPAREN          shift and go to state 177


state 162

    (33) item -> value .

    ARROW           reduce using rule 33 (item -> value .)
    COMMA           reduce using rule 33 (item -> value .)
    RPAREN          reduce using rule 33 (item -> value .)


state 163

    (34) item -> stack .

    ARROW           reduce using rule 34 (item -> stack .)
    COMMA           reduce using rule 34 (item -> stack .)
    RPAREN          reduce using rule 34 (item -> stack .)


state 164

    (35) item -> array .

    ARROW           reduce using rule 35 (item -> array .)
    COMMA           reduce using rule 35 (item -> array .)
    RPAREN          reduce using rule 35 (item -> array .)


state 165

    (36) item -> queue .

    ARROW           reduce using rule 36 (item -> queue .)
    COMMA           reduce using rule 36 (item -> queue .)
    RPAREN          reduce using rule 36 (item -> queue .)


state 166

    (29) value -> IDENTIFIER .
    (57) stack -> IDENTIFIER . ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (46) array -> IDENTIFIER . ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON

    ARROW           reduce using rule 29 (value -> IDENTIFIER .)
    COMMA           reduce using rule 29 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 29 (value -> IDENTIFIER .)
    ASSINGMENT      shift and go to state 178


state 167

    (56) queue -> NEW . QUEUE LPAREN RPAREN

    QUEUE           shift and go to state 179


state 168

    (75) elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 75 (elseif -> CURLYRIGHTBRACKET ELSEIF LPAREN condition RPAREN CURLYLEFTBRACKET .)


state 169

    (81) foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 180


state 170

    (67) function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .

    $end            reduce using rule 67 (function -> IDENTIFIER ASSINGMENT NAMEFUNCTION LPAREN parameter RPAREN SEMICOLON .)


state 171

    (46) array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .

    $end            reduce using rule 46 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)
    ARROW           reduce using rule 46 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)
    COMMA           reduce using rule 46 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)
    RPAREN          reduce using rule 46 (array -> IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON .)


state 172

    (57) stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 57 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)
    ARROW           reduce using rule 57 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)
    COMMA           reduce using rule 57 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)
    RPAREN          reduce using rule 57 (stack -> IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON .)


state 173

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW . item RPAREN SEMICOLON
    (52) itemsARROW -> item ARROW . item repite_items_f
    (33) item -> . value
    (34) item -> . stack
    (35) item -> . array
    (36) item -> . queue
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING
    (57) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (46) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (50) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (56) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 166
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48
    DOLLARSIGN      shift and go to state 28
    NEW             shift and go to state 167

    item                           shift and go to state 181
    value                          shift and go to state 162
    stack                          shift and go to state 163
    array                          shift and go to state 164
    queue                          shift and go to state 165

state 174

    (47) items -> item repite_items .

    RPAREN          reduce using rule 47 (items -> item repite_items .)


state 175

    (48) repite_items -> COMMA . item
    (49) repite_items -> COMMA . item repite_items
    (33) item -> . value
    (34) item -> . stack
    (35) item -> . array
    (36) item -> . queue
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING
    (57) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (46) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (50) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (56) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 166
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48
    DOLLARSIGN      shift and go to state 28
    NEW             shift and go to state 167

    item                           shift and go to state 182
    value                          shift and go to state 162
    stack                          shift and go to state 163
    array                          shift and go to state 164
    queue                          shift and go to state 165

state 176

    (51) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 183


state 177

    (55) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 184


state 178

    (57) stack -> IDENTIFIER ASSINGMENT . NEW STACK LPAREN RPAREN SEMICOLON
    (46) array -> IDENTIFIER ASSINGMENT . ARRAY LPAREN INTEGER RPAREN SEMICOLON

    NEW             shift and go to state 79
    ARRAY           shift and go to state 78


state 179

    (56) queue -> NEW QUEUE . LPAREN RPAREN

    LPAREN          shift and go to state 185


state 180

    (81) foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 81 (foreach -> FOREACH LPAREN IDENTIFIER CHAIN IDENTIFIER RPAREN CURLYLEFTBRACKET .)


state 181

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item . RPAREN SEMICOLON
    (52) itemsARROW -> item ARROW item . repite_items_f
    (53) repite_items_f -> . COMMA item ARROW item
    (54) repite_items_f -> . COMMA item ARROW item repite_items

    RPAREN          shift and go to state 186
    COMMA           shift and go to state 188

    repite_items_f                 shift and go to state 187

state 182

    (48) repite_items -> COMMA item .
    (49) repite_items -> COMMA item . repite_items
    (48) repite_items -> . COMMA item
    (49) repite_items -> . COMMA item repite_items

    RPAREN          reduce using rule 48 (repite_items -> COMMA item .)
    COMMA           shift and go to state 175

    repite_items                   shift and go to state 189

state 183

    (51) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .

    $end            reduce using rule 51 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)
    ARROW           reduce using rule 51 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)
    COMMA           reduce using rule 51 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)
    RPAREN          reduce using rule 51 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON .)


state 184

    (55) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .

    $end            reduce using rule 55 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)
    ARROW           reduce using rule 55 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)
    COMMA           reduce using rule 55 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)
    RPAREN          reduce using rule 55 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON .)


state 185

    (56) queue -> NEW QUEUE LPAREN . RPAREN

    RPAREN          shift and go to state 190


state 186

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 191


state 187

    (52) itemsARROW -> item ARROW item repite_items_f .

    RPAREN          reduce using rule 52 (itemsARROW -> item ARROW item repite_items_f .)


state 188

    (53) repite_items_f -> COMMA . item ARROW item
    (54) repite_items_f -> COMMA . item ARROW item repite_items
    (33) item -> . value
    (34) item -> . stack
    (35) item -> . array
    (36) item -> . queue
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING
    (57) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (46) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (50) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (56) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 166
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48
    DOLLARSIGN      shift and go to state 28
    NEW             shift and go to state 167

    item                           shift and go to state 192
    value                          shift and go to state 162
    stack                          shift and go to state 163
    array                          shift and go to state 164
    queue                          shift and go to state 165

state 189

    (49) repite_items -> COMMA item repite_items .

    RPAREN          reduce using rule 49 (repite_items -> COMMA item repite_items .)


state 190

    (56) queue -> NEW QUEUE LPAREN RPAREN .

    ARROW           reduce using rule 56 (queue -> NEW QUEUE LPAREN RPAREN .)
    COMMA           reduce using rule 56 (queue -> NEW QUEUE LPAREN RPAREN .)
    RPAREN          reduce using rule 56 (queue -> NEW QUEUE LPAREN RPAREN .)


state 191

    (50) array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON .

    $end            reduce using rule 50 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON .)
    ARROW           reduce using rule 50 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON .)
    COMMA           reduce using rule 50 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON .)
    RPAREN          reduce using rule 50 (array -> DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON .)


state 192

    (53) repite_items_f -> COMMA item . ARROW item
    (54) repite_items_f -> COMMA item . ARROW item repite_items

    ARROW           shift and go to state 193


state 193

    (53) repite_items_f -> COMMA item ARROW . item
    (54) repite_items_f -> COMMA item ARROW . item repite_items
    (33) item -> . value
    (34) item -> . stack
    (35) item -> . array
    (36) item -> . queue
    (27) value -> . INTEGER
    (28) value -> . FLOAT
    (29) value -> . IDENTIFIER
    (30) value -> . TRUE
    (31) value -> . FALSE
    (32) value -> . STRING
    (57) stack -> . IDENTIFIER ASSINGMENT NEW STACK LPAREN RPAREN SEMICOLON
    (46) array -> . IDENTIFIER ASSINGMENT ARRAY LPAREN INTEGER RPAREN SEMICOLON
    (50) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN item ARROW item RPAREN SEMICOLON
    (51) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN items RPAREN SEMICOLON
    (55) array -> . DOLLARSIGN CHAIN ASSINGMENT ARRAY LPAREN itemsARROW RPAREN SEMICOLON
    (56) queue -> . NEW QUEUE LPAREN RPAREN

    INTEGER         shift and go to state 43
    FLOAT           shift and go to state 44
    IDENTIFIER      shift and go to state 166
    TRUE            shift and go to state 46
    FALSE           shift and go to state 47
    STRING          shift and go to state 48
    DOLLARSIGN      shift and go to state 28
    NEW             shift and go to state 167

    item                           shift and go to state 194
    value                          shift and go to state 162
    stack                          shift and go to state 163
    array                          shift and go to state 164
    queue                          shift and go to state 165

state 194

    (53) repite_items_f -> COMMA item ARROW item .
    (54) repite_items_f -> COMMA item ARROW item . repite_items
    (48) repite_items -> . COMMA item
    (49) repite_items -> . COMMA item repite_items

    RPAREN          reduce using rule 53 (repite_items_f -> COMMA item ARROW item .)
    COMMA           shift and go to state 175

    repite_items                   shift and go to state 195

state 195

    (54) repite_items_f -> COMMA item ARROW item repite_items .

    RPAREN          reduce using rule 54 (repite_items_f -> COMMA item ARROW item repite_items .)

