Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANDEQUAL
    APOSTROPHE
    ARRAY
    ARROW
    ATTACH
    BREAK
    CASE
    CATCH
    CLASS
    COLON
    COMMENTS
    CONTAINS
    CONTINUE
    CURLYRIGHTBRACKET
    DECLARE
    DECREMENT
    DEFAULT
    DIE
    DIVIDE
    DO
    DOLLARSIGN
    DOT
    DOUBLECOLON
    ECHO
    ELSE
    ELSEIF
    ENDFOR
    ENDFOREACH
    ENDIF
    EQUALS
    EXIT
    EXTENDS
    FIXEDARRAY
    FOR
    FOREACH
    FORMAT
    GOTO
    GREATERTHANEQ
    HEAP
    IDENTICAL
    IF
    INCREMENT
    INTDIVIDE
    LBRACKET
    LESSTHAN
    LESSTHANEQ
    MAXHEAP
    MINHEAP
    MODULE
    NOTIDENTICAL
    OBJECTSTORAGE
    OR
    PLUS
    POWERBY
    PRIORITYQUEUE
    PUBLIC
    QUEUE
    RBRACKET
    SIMPLEARROW
    STACK
    STATIC
    SWITCH
    TIMES
    TRY
    WHILE
    XOR

Grammar

Rule 0     S' -> sentence
Rule 1     sentence -> print
Rule 2     sentence -> printf
Rule 3     sentence -> assignment
Rule 4     sentence -> input
Rule 5     sentence -> function
Rule 6     sentence -> return
Rule 7     sentence -> array
Rule 8     sentence -> stack
Rule 9     sentence -> op_stack
Rule 10    sentence -> operad_stack
Rule 11    assignment -> IDENTIFIER ASSINGMENT values SEMICOLON
Rule 12    print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 13    print -> PRINT value SEMICOLON
Rule 14    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 15    printf -> PRINTF LPAREN values RPAREN SEMICOLON
Rule 16    input -> FGETS LPAREN values RPAREN SEMICOLON
Rule 17    values -> value
Rule 18    values -> value COMMA values
Rule 19    value -> INTEGER
Rule 20    value -> FLOAT
Rule 21    value -> IDENTIFIER
Rule 22    value -> TRUE
Rule 23    value -> FALSE
Rule 24    value -> STRING
Rule 25    array -> IDENTIFIER ASSINGMENT NEW NAMEFUNCTION LPAREN INTEGER RPAREN SEMICOLON
Rule 26    stack -> NEW NAMEFUNCTION LPAREN RPAREN
Rule 27    op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack
Rule 28    operad_stack -> PUSH LPAREN values RPAREN SEMICOLON
Rule 29    operad_stack -> POP LPAREN RPAREN SEMICOLON
Rule 30    operad_stack -> COUNT LPAREN RPAREN SEMICOLON
Rule 31    operad_stack -> CURRENT LPAREN RPAREN SEMICOLON
Rule 32    function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
Rule 33    parameter -> IDENTIFIER
Rule 34    parameter -> IDENTIFIER COMMA parameter
Rule 35    function -> NAMEFUNCTION LPAREN parameter RPAREN
Rule 36    return -> RETURN IDENTIFIER SEMICOLON

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 
APOSTROPHE           : 
ARRAY                : 
ARROW                : 
ASSINGMENT           : 11 25
ATTACH               : 
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 
COMMA                : 18 34
COMMENTS             : 
CONTAINS             : 
CONTINUE             : 
COUNT                : 30
CURLYLEFTBRACKET     : 32
CURLYRIGHTBRACKET    : 
CURRENT              : 31
DECLARE              : 
DECREMENT            : 
DEFAULT              : 
DIE                  : 
DIVIDE               : 
DO                   : 
DOLLARSIGN           : 
DOT                  : 
DOUBLECOLON          : 
ECHO                 : 
ELSE                 : 
ELSEIF               : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
EQUALS               : 
EXIT                 : 
EXTENDS              : 
FALSE                : 23
FGETS                : 16
FIXEDARRAY           : 
FLOAT                : 20
FOR                  : 
FOREACH              : 
FORMAT               : 
FUNCTION             : 32
GOTO                 : 
GREATERTHAN          : 27
GREATERTHANEQ        : 
HEAP                 : 
IDENTICAL            : 
IDENTIFIER           : 11 21 25 27 33 34 36
IF                   : 
INCREMENT            : 
INTDIVIDE            : 
INTEGER              : 19 25
LBRACKET             : 
LESSTHAN             : 
LESSTHANEQ           : 
LPAREN               : 12 14 15 16 25 26 28 29 30 31 32 35
MAXHEAP              : 
MINHEAP              : 
MINUS                : 27
MODULE               : 
NAMEFUNCTION         : 25 26 32 35
NEW                  : 25 26
NOTIDENTICAL         : 
OBJECTSTORAGE        : 
OR                   : 
PLUS                 : 
POP                  : 29
POWERBY              : 
PRINT                : 12 13 14
PRINTF               : 15
PRIORITYQUEUE        : 
PUBLIC               : 
PUSH                 : 28
QUEUE                : 
RBRACKET             : 
RETURN               : 36
RPAREN               : 12 14 15 16 25 26 28 29 30 31 32 35
SEMICOLON            : 11 12 13 14 15 16 25 28 29 30 31 36
SIMPLEARROW          : 
STACK                : 
STATIC               : 
STRING               : 24
SWITCH               : 
TIMES                : 
TRUE                 : 22
TRY                  : 
WHILE                : 
XOR                  : 
error                : 

Nonterminals, with rules where they appear

array                : 7
assignment           : 3
function             : 5
input                : 4
op_stack             : 9
operad_stack         : 10 27
parameter            : 32 34 35
print                : 1
printf               : 2
return               : 6
sentence             : 0
stack                : 8
value                : 13 17 18
values               : 11 12 15 16 18 28

Parsing method: LALR

state 0

    (0) S' -> . sentence
    (1) sentence -> . print
    (2) sentence -> . printf
    (3) sentence -> . assignment
    (4) sentence -> . input
    (5) sentence -> . function
    (6) sentence -> . return
    (7) sentence -> . array
    (8) sentence -> . stack
    (9) sentence -> . op_stack
    (10) sentence -> . operad_stack
    (12) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (13) print -> . PRINT value SEMICOLON
    (14) print -> . PRINT LPAREN RPAREN SEMICOLON
    (15) printf -> . PRINTF LPAREN values RPAREN SEMICOLON
    (11) assignment -> . IDENTIFIER ASSINGMENT values SEMICOLON
    (16) input -> . FGETS LPAREN values RPAREN SEMICOLON
    (32) function -> . FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
    (35) function -> . NAMEFUNCTION LPAREN parameter RPAREN
    (36) return -> . RETURN IDENTIFIER SEMICOLON
    (25) array -> . IDENTIFIER ASSINGMENT NEW NAMEFUNCTION LPAREN INTEGER RPAREN SEMICOLON
    (26) stack -> . NEW NAMEFUNCTION LPAREN RPAREN
    (27) op_stack -> . IDENTIFIER MINUS GREATERTHAN operad_stack
    (28) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (29) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (30) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (31) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON

    PRINT           shift and go to state 12
    PRINTF          shift and go to state 13
    IDENTIFIER      shift and go to state 14
    FGETS           shift and go to state 15
    FUNCTION        shift and go to state 16
    NAMEFUNCTION    shift and go to state 17
    RETURN          shift and go to state 18
    NEW             shift and go to state 19
    PUSH            shift and go to state 20
    POP             shift and go to state 21
    COUNT           shift and go to state 22
    CURRENT         shift and go to state 23

    sentence                       shift and go to state 1
    print                          shift and go to state 2
    printf                         shift and go to state 3
    assignment                     shift and go to state 4
    input                          shift and go to state 5
    function                       shift and go to state 6
    return                         shift and go to state 7
    array                          shift and go to state 8
    stack                          shift and go to state 9
    op_stack                       shift and go to state 10
    operad_stack                   shift and go to state 11

state 1

    (0) S' -> sentence .



state 2

    (1) sentence -> print .

    $end            reduce using rule 1 (sentence -> print .)


state 3

    (2) sentence -> printf .

    $end            reduce using rule 2 (sentence -> printf .)


state 4

    (3) sentence -> assignment .

    $end            reduce using rule 3 (sentence -> assignment .)


state 5

    (4) sentence -> input .

    $end            reduce using rule 4 (sentence -> input .)


state 6

    (5) sentence -> function .

    $end            reduce using rule 5 (sentence -> function .)


state 7

    (6) sentence -> return .

    $end            reduce using rule 6 (sentence -> return .)


state 8

    (7) sentence -> array .

    $end            reduce using rule 7 (sentence -> array .)


state 9

    (8) sentence -> stack .

    $end            reduce using rule 8 (sentence -> stack .)


state 10

    (9) sentence -> op_stack .

    $end            reduce using rule 9 (sentence -> op_stack .)


state 11

    (10) sentence -> operad_stack .

    $end            reduce using rule 10 (sentence -> operad_stack .)


state 12

    (12) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (13) print -> PRINT . value SEMICOLON
    (14) print -> PRINT . LPAREN RPAREN SEMICOLON
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . IDENTIFIER
    (22) value -> . TRUE
    (23) value -> . FALSE
    (24) value -> . STRING

    LPAREN          shift and go to state 24
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    STRING          shift and go to state 31

    value                          shift and go to state 25

state 13

    (15) printf -> PRINTF . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 32


state 14

    (11) assignment -> IDENTIFIER . ASSINGMENT values SEMICOLON
    (25) array -> IDENTIFIER . ASSINGMENT NEW NAMEFUNCTION LPAREN INTEGER RPAREN SEMICOLON
    (27) op_stack -> IDENTIFIER . MINUS GREATERTHAN operad_stack

    ASSINGMENT      shift and go to state 33
    MINUS           shift and go to state 34


state 15

    (16) input -> FGETS . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 35


state 16

    (32) function -> FUNCTION . NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET

    NAMEFUNCTION    shift and go to state 36


state 17

    (35) function -> NAMEFUNCTION . LPAREN parameter RPAREN

    LPAREN          shift and go to state 37


state 18

    (36) return -> RETURN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 38


state 19

    (26) stack -> NEW . NAMEFUNCTION LPAREN RPAREN

    NAMEFUNCTION    shift and go to state 39


state 20

    (28) operad_stack -> PUSH . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 40


state 21

    (29) operad_stack -> POP . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 41


state 22

    (30) operad_stack -> COUNT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 42


state 23

    (31) operad_stack -> CURRENT . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 43


state 24

    (12) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (14) print -> PRINT LPAREN . RPAREN SEMICOLON
    (17) values -> . value
    (18) values -> . value COMMA values
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . IDENTIFIER
    (22) value -> . TRUE
    (23) value -> . FALSE
    (24) value -> . STRING

    RPAREN          shift and go to state 45
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    STRING          shift and go to state 31

    values                         shift and go to state 44
    value                          shift and go to state 46

state 25

    (13) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 47


state 26

    (19) value -> INTEGER .

    SEMICOLON       reduce using rule 19 (value -> INTEGER .)
    COMMA           reduce using rule 19 (value -> INTEGER .)
    RPAREN          reduce using rule 19 (value -> INTEGER .)


state 27

    (20) value -> FLOAT .

    SEMICOLON       reduce using rule 20 (value -> FLOAT .)
    COMMA           reduce using rule 20 (value -> FLOAT .)
    RPAREN          reduce using rule 20 (value -> FLOAT .)


state 28

    (21) value -> IDENTIFIER .

    SEMICOLON       reduce using rule 21 (value -> IDENTIFIER .)
    COMMA           reduce using rule 21 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 21 (value -> IDENTIFIER .)


state 29

    (22) value -> TRUE .

    SEMICOLON       reduce using rule 22 (value -> TRUE .)
    COMMA           reduce using rule 22 (value -> TRUE .)
    RPAREN          reduce using rule 22 (value -> TRUE .)


state 30

    (23) value -> FALSE .

    SEMICOLON       reduce using rule 23 (value -> FALSE .)
    COMMA           reduce using rule 23 (value -> FALSE .)
    RPAREN          reduce using rule 23 (value -> FALSE .)


state 31

    (24) value -> STRING .

    SEMICOLON       reduce using rule 24 (value -> STRING .)
    COMMA           reduce using rule 24 (value -> STRING .)
    RPAREN          reduce using rule 24 (value -> STRING .)


state 32

    (15) printf -> PRINTF LPAREN . values RPAREN SEMICOLON
    (17) values -> . value
    (18) values -> . value COMMA values
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . IDENTIFIER
    (22) value -> . TRUE
    (23) value -> . FALSE
    (24) value -> . STRING

    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    STRING          shift and go to state 31

    values                         shift and go to state 48
    value                          shift and go to state 46

state 33

    (11) assignment -> IDENTIFIER ASSINGMENT . values SEMICOLON
    (25) array -> IDENTIFIER ASSINGMENT . NEW NAMEFUNCTION LPAREN INTEGER RPAREN SEMICOLON
    (17) values -> . value
    (18) values -> . value COMMA values
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . IDENTIFIER
    (22) value -> . TRUE
    (23) value -> . FALSE
    (24) value -> . STRING

    NEW             shift and go to state 50
    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    STRING          shift and go to state 31

    values                         shift and go to state 49
    value                          shift and go to state 46

state 34

    (27) op_stack -> IDENTIFIER MINUS . GREATERTHAN operad_stack

    GREATERTHAN     shift and go to state 51


state 35

    (16) input -> FGETS LPAREN . values RPAREN SEMICOLON
    (17) values -> . value
    (18) values -> . value COMMA values
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . IDENTIFIER
    (22) value -> . TRUE
    (23) value -> . FALSE
    (24) value -> . STRING

    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    STRING          shift and go to state 31

    values                         shift and go to state 52
    value                          shift and go to state 46

state 36

    (32) function -> FUNCTION NAMEFUNCTION . LPAREN parameter RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 53


state 37

    (35) function -> NAMEFUNCTION LPAREN . parameter RPAREN
    (33) parameter -> . IDENTIFIER
    (34) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 55

    parameter                      shift and go to state 54

state 38

    (36) return -> RETURN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 56


state 39

    (26) stack -> NEW NAMEFUNCTION . LPAREN RPAREN

    LPAREN          shift and go to state 57


state 40

    (28) operad_stack -> PUSH LPAREN . values RPAREN SEMICOLON
    (17) values -> . value
    (18) values -> . value COMMA values
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . IDENTIFIER
    (22) value -> . TRUE
    (23) value -> . FALSE
    (24) value -> . STRING

    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    STRING          shift and go to state 31

    values                         shift and go to state 58
    value                          shift and go to state 46

state 41

    (29) operad_stack -> POP LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 59


state 42

    (30) operad_stack -> COUNT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 60


state 43

    (31) operad_stack -> CURRENT LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 61


state 44

    (12) print -> PRINT LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 62


state 45

    (14) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 63


state 46

    (17) values -> value .
    (18) values -> value . COMMA values

    RPAREN          reduce using rule 17 (values -> value .)
    SEMICOLON       reduce using rule 17 (values -> value .)
    COMMA           shift and go to state 64


state 47

    (13) print -> PRINT value SEMICOLON .

    $end            reduce using rule 13 (print -> PRINT value SEMICOLON .)


state 48

    (15) printf -> PRINTF LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 65


state 49

    (11) assignment -> IDENTIFIER ASSINGMENT values . SEMICOLON

    SEMICOLON       shift and go to state 66


state 50

    (25) array -> IDENTIFIER ASSINGMENT NEW . NAMEFUNCTION LPAREN INTEGER RPAREN SEMICOLON

    NAMEFUNCTION    shift and go to state 67


state 51

    (27) op_stack -> IDENTIFIER MINUS GREATERTHAN . operad_stack
    (28) operad_stack -> . PUSH LPAREN values RPAREN SEMICOLON
    (29) operad_stack -> . POP LPAREN RPAREN SEMICOLON
    (30) operad_stack -> . COUNT LPAREN RPAREN SEMICOLON
    (31) operad_stack -> . CURRENT LPAREN RPAREN SEMICOLON

    PUSH            shift and go to state 20
    POP             shift and go to state 21
    COUNT           shift and go to state 22
    CURRENT         shift and go to state 23

    operad_stack                   shift and go to state 68

state 52

    (16) input -> FGETS LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 69


state 53

    (32) function -> FUNCTION NAMEFUNCTION LPAREN . parameter RPAREN CURLYLEFTBRACKET
    (33) parameter -> . IDENTIFIER
    (34) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 55

    parameter                      shift and go to state 70

state 54

    (35) function -> NAMEFUNCTION LPAREN parameter . RPAREN

    RPAREN          shift and go to state 71


state 55

    (33) parameter -> IDENTIFIER .
    (34) parameter -> IDENTIFIER . COMMA parameter

    RPAREN          reduce using rule 33 (parameter -> IDENTIFIER .)
    COMMA           shift and go to state 72


state 56

    (36) return -> RETURN IDENTIFIER SEMICOLON .

    $end            reduce using rule 36 (return -> RETURN IDENTIFIER SEMICOLON .)


state 57

    (26) stack -> NEW NAMEFUNCTION LPAREN . RPAREN

    RPAREN          shift and go to state 73


state 58

    (28) operad_stack -> PUSH LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 74


state 59

    (29) operad_stack -> POP LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 75


state 60

    (30) operad_stack -> COUNT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 76


state 61

    (31) operad_stack -> CURRENT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 77


state 62

    (12) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 78


state 63

    (14) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 14 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 64

    (18) values -> value COMMA . values
    (17) values -> . value
    (18) values -> . value COMMA values
    (19) value -> . INTEGER
    (20) value -> . FLOAT
    (21) value -> . IDENTIFIER
    (22) value -> . TRUE
    (23) value -> . FALSE
    (24) value -> . STRING

    INTEGER         shift and go to state 26
    FLOAT           shift and go to state 27
    IDENTIFIER      shift and go to state 28
    TRUE            shift and go to state 29
    FALSE           shift and go to state 30
    STRING          shift and go to state 31

    value                          shift and go to state 46
    values                         shift and go to state 79

state 65

    (15) printf -> PRINTF LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 80


state 66

    (11) assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .

    $end            reduce using rule 11 (assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .)


state 67

    (25) array -> IDENTIFIER ASSINGMENT NEW NAMEFUNCTION . LPAREN INTEGER RPAREN SEMICOLON

    LPAREN          shift and go to state 81


state 68

    (27) op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .

    $end            reduce using rule 27 (op_stack -> IDENTIFIER MINUS GREATERTHAN operad_stack .)


state 69

    (16) input -> FGETS LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 82


state 70

    (32) function -> FUNCTION NAMEFUNCTION LPAREN parameter . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 83


state 71

    (35) function -> NAMEFUNCTION LPAREN parameter RPAREN .

    $end            reduce using rule 35 (function -> NAMEFUNCTION LPAREN parameter RPAREN .)


state 72

    (34) parameter -> IDENTIFIER COMMA . parameter
    (33) parameter -> . IDENTIFIER
    (34) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 55

    parameter                      shift and go to state 84

state 73

    (26) stack -> NEW NAMEFUNCTION LPAREN RPAREN .

    $end            reduce using rule 26 (stack -> NEW NAMEFUNCTION LPAREN RPAREN .)


state 74

    (28) operad_stack -> PUSH LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 85


state 75

    (29) operad_stack -> POP LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 29 (operad_stack -> POP LPAREN RPAREN SEMICOLON .)


state 76

    (30) operad_stack -> COUNT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 30 (operad_stack -> COUNT LPAREN RPAREN SEMICOLON .)


state 77

    (31) operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 31 (operad_stack -> CURRENT LPAREN RPAREN SEMICOLON .)


state 78

    (12) print -> PRINT LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 12 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 79

    (18) values -> value COMMA values .

    RPAREN          reduce using rule 18 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 18 (values -> value COMMA values .)


state 80

    (15) printf -> PRINTF LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 15 (printf -> PRINTF LPAREN values RPAREN SEMICOLON .)


state 81

    (25) array -> IDENTIFIER ASSINGMENT NEW NAMEFUNCTION LPAREN . INTEGER RPAREN SEMICOLON

    INTEGER         shift and go to state 86


state 82

    (16) input -> FGETS LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 16 (input -> FGETS LPAREN values RPAREN SEMICOLON .)


state 83

    (32) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 87


state 84

    (34) parameter -> IDENTIFIER COMMA parameter .

    RPAREN          reduce using rule 34 (parameter -> IDENTIFIER COMMA parameter .)


state 85

    (28) operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 28 (operad_stack -> PUSH LPAREN values RPAREN SEMICOLON .)


state 86

    (25) array -> IDENTIFIER ASSINGMENT NEW NAMEFUNCTION LPAREN INTEGER . RPAREN SEMICOLON

    RPAREN          shift and go to state 88


state 87

    (32) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 32 (function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .)


state 88

    (25) array -> IDENTIFIER ASSINGMENT NEW NAMEFUNCTION LPAREN INTEGER RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 89


state 89

    (25) array -> IDENTIFIER ASSINGMENT NEW NAMEFUNCTION LPAREN INTEGER RPAREN SEMICOLON .

    $end            reduce using rule 25 (array -> IDENTIFIER ASSINGMENT NEW NAMEFUNCTION LPAREN INTEGER RPAREN SEMICOLON .)

