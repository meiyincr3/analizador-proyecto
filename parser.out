Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANDEQUAL
    APOSTROPHE
    ARRAY
    ARROW
    ATTACH
    BREAK
    CASE
    CATCH
    CLASS
    COLON
    COMMENTS
    CONTAINS
    CONTINUE
    COUNT
    CURLYRIGHTBRACKET
    CURRENT
    DECLARE
    DECREMENT
    DEFAULT
    DIE
    DIVIDE
    DO
    DOLLARSIGN
    DOT
    DOUBLECOLON
    ECHO
    ELSE
    ELSEIF
    ENDFOR
    ENDFOREACH
    ENDIF
    EQUALS
    EXIT
    EXTENDS
    FIXEDARRAY
    FOR
    FOREACH
    GOTO
    GREATERTHAN
    GREATERTHANEQ
    HEAP
    IDENTICAL
    IF
    INCREMENT
    INTDIVIDE
    LBRACKET
    LESSTHAN
    LESSTHANEQ
    MAXHEAP
    MINHEAP
    MINUS
    MODULE
    NEW
    NOTIDENTICAL
    OBJECTSTORAGE
    OR
    PLUS
    POP
    POWERBY
    PRIORITYQUEUE
    PUBLIC
    PUSH
    QUEUE
    RBRACKET
    SIMPLEARROW
    STACK
    STATIC
    SWITCH
    TIMES
    TRY
    WHILE
    XOR

Grammar

Rule 0     S' -> sentence
Rule 1     sentence -> print
Rule 2     sentence -> assignment
Rule 3     sentence -> input
Rule 4     sentence -> function
Rule 5     sentence -> return
Rule 6     assignment -> IDENTIFIER ASSINGMENT values SEMICOLON
Rule 7     print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 8     print -> PRINT value SEMICOLON
Rule 9     print -> PRINT LPAREN RPAREN SEMICOLON
Rule 10    input -> FGETS LPAREN RPAREN SEMICOLON
Rule 11    values -> value
Rule 12    values -> value COMMA values
Rule 13    value -> INTEGER
Rule 14    value -> FLOAT
Rule 15    value -> IDENTIFIER
Rule 16    value -> TRUE
Rule 17    value -> FALSE
Rule 18    value -> STRING
Rule 19    function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
Rule 20    parameter -> IDENTIFIER
Rule 21    parameter -> IDENTIFIER COMMA parameter
Rule 22    function -> NAMEFUNCTION LPAREN parameter RPAREN
Rule 23    return -> RETURN IDENTIFIER SEMICOLON

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 
APOSTROPHE           : 
ARRAY                : 
ARROW                : 
ASSINGMENT           : 6
ATTACH               : 
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 
COMMA                : 12 21
COMMENTS             : 
CONTAINS             : 
CONTINUE             : 
COUNT                : 
CURLYLEFTBRACKET     : 19
CURLYRIGHTBRACKET    : 
CURRENT              : 
DECLARE              : 
DECREMENT            : 
DEFAULT              : 
DIE                  : 
DIVIDE               : 
DO                   : 
DOLLARSIGN           : 
DOT                  : 
DOUBLECOLON          : 
ECHO                 : 
ELSE                 : 
ELSEIF               : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
EQUALS               : 
EXIT                 : 
EXTENDS              : 
FALSE                : 17
FGETS                : 10
FIXEDARRAY           : 
FLOAT                : 14
FOR                  : 
FOREACH              : 
FUNCTION             : 19
GOTO                 : 
GREATERTHAN          : 
GREATERTHANEQ        : 
HEAP                 : 
IDENTICAL            : 
IDENTIFIER           : 6 15 20 21 23
IF                   : 
INCREMENT            : 
INTDIVIDE            : 
INTEGER              : 13
LBRACKET             : 
LESSTHAN             : 
LESSTHANEQ           : 
LPAREN               : 7 9 10 19 22
MAXHEAP              : 
MINHEAP              : 
MINUS                : 
MODULE               : 
NAMEFUNCTION         : 19 22
NEW                  : 
NOTIDENTICAL         : 
OBJECTSTORAGE        : 
OR                   : 
PLUS                 : 
POP                  : 
POWERBY              : 
PRINT                : 7 8 9
PRIORITYQUEUE        : 
PUBLIC               : 
PUSH                 : 
QUEUE                : 
RBRACKET             : 
RETURN               : 23
RPAREN               : 7 9 10 19 22
SEMICOLON            : 6 7 8 9 10 23
SIMPLEARROW          : 
STACK                : 
STATIC               : 
STRING               : 18
SWITCH               : 
TIMES                : 
TRUE                 : 16
TRY                  : 
WHILE                : 
XOR                  : 
error                : 

Nonterminals, with rules where they appear

assignment           : 2
function             : 4
input                : 3
parameter            : 19 21 22
print                : 1
return               : 5
sentence             : 0
value                : 8 11 12
values               : 6 7 12

Parsing method: LALR

state 0

    (0) S' -> . sentence
    (1) sentence -> . print
    (2) sentence -> . assignment
    (3) sentence -> . input
    (4) sentence -> . function
    (5) sentence -> . return
    (7) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (8) print -> . PRINT value SEMICOLON
    (9) print -> . PRINT LPAREN RPAREN SEMICOLON
    (6) assignment -> . IDENTIFIER ASSINGMENT values SEMICOLON
    (10) input -> . FGETS LPAREN RPAREN SEMICOLON
    (19) function -> . FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
    (22) function -> . NAMEFUNCTION LPAREN parameter RPAREN
    (23) return -> . RETURN IDENTIFIER SEMICOLON

    PRINT           shift and go to state 7
    IDENTIFIER      shift and go to state 8
    FGETS           shift and go to state 9
    FUNCTION        shift and go to state 10
    NAMEFUNCTION    shift and go to state 11
    RETURN          shift and go to state 12

    sentence                       shift and go to state 1
    print                          shift and go to state 2
    assignment                     shift and go to state 3
    input                          shift and go to state 4
    function                       shift and go to state 5
    return                         shift and go to state 6

state 1

    (0) S' -> sentence .



state 2

    (1) sentence -> print .

    $end            reduce using rule 1 (sentence -> print .)


state 3

    (2) sentence -> assignment .

    $end            reduce using rule 2 (sentence -> assignment .)


state 4

    (3) sentence -> input .

    $end            reduce using rule 3 (sentence -> input .)


state 5

    (4) sentence -> function .

    $end            reduce using rule 4 (sentence -> function .)


state 6

    (5) sentence -> return .

    $end            reduce using rule 5 (sentence -> return .)


state 7

    (7) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (8) print -> PRINT . value SEMICOLON
    (9) print -> PRINT . LPAREN RPAREN SEMICOLON
    (13) value -> . INTEGER
    (14) value -> . FLOAT
    (15) value -> . IDENTIFIER
    (16) value -> . TRUE
    (17) value -> . FALSE
    (18) value -> . STRING

    LPAREN          shift and go to state 13
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16
    IDENTIFIER      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    STRING          shift and go to state 20

    value                          shift and go to state 14

state 8

    (6) assignment -> IDENTIFIER . ASSINGMENT values SEMICOLON

    ASSINGMENT      shift and go to state 21


state 9

    (10) input -> FGETS . LPAREN RPAREN SEMICOLON

    LPAREN          shift and go to state 22


state 10

    (19) function -> FUNCTION . NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET

    NAMEFUNCTION    shift and go to state 23


state 11

    (22) function -> NAMEFUNCTION . LPAREN parameter RPAREN

    LPAREN          shift and go to state 24


state 12

    (23) return -> RETURN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 25


state 13

    (7) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (9) print -> PRINT LPAREN . RPAREN SEMICOLON
    (11) values -> . value
    (12) values -> . value COMMA values
    (13) value -> . INTEGER
    (14) value -> . FLOAT
    (15) value -> . IDENTIFIER
    (16) value -> . TRUE
    (17) value -> . FALSE
    (18) value -> . STRING

    RPAREN          shift and go to state 27
    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16
    IDENTIFIER      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    STRING          shift and go to state 20

    values                         shift and go to state 26
    value                          shift and go to state 28

state 14

    (8) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 29


state 15

    (13) value -> INTEGER .

    SEMICOLON       reduce using rule 13 (value -> INTEGER .)
    COMMA           reduce using rule 13 (value -> INTEGER .)
    RPAREN          reduce using rule 13 (value -> INTEGER .)


state 16

    (14) value -> FLOAT .

    SEMICOLON       reduce using rule 14 (value -> FLOAT .)
    COMMA           reduce using rule 14 (value -> FLOAT .)
    RPAREN          reduce using rule 14 (value -> FLOAT .)


state 17

    (15) value -> IDENTIFIER .

    SEMICOLON       reduce using rule 15 (value -> IDENTIFIER .)
    COMMA           reduce using rule 15 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 15 (value -> IDENTIFIER .)


state 18

    (16) value -> TRUE .

    SEMICOLON       reduce using rule 16 (value -> TRUE .)
    COMMA           reduce using rule 16 (value -> TRUE .)
    RPAREN          reduce using rule 16 (value -> TRUE .)


state 19

    (17) value -> FALSE .

    SEMICOLON       reduce using rule 17 (value -> FALSE .)
    COMMA           reduce using rule 17 (value -> FALSE .)
    RPAREN          reduce using rule 17 (value -> FALSE .)


state 20

    (18) value -> STRING .

    SEMICOLON       reduce using rule 18 (value -> STRING .)
    COMMA           reduce using rule 18 (value -> STRING .)
    RPAREN          reduce using rule 18 (value -> STRING .)


state 21

    (6) assignment -> IDENTIFIER ASSINGMENT . values SEMICOLON
    (11) values -> . value
    (12) values -> . value COMMA values
    (13) value -> . INTEGER
    (14) value -> . FLOAT
    (15) value -> . IDENTIFIER
    (16) value -> . TRUE
    (17) value -> . FALSE
    (18) value -> . STRING

    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16
    IDENTIFIER      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    STRING          shift and go to state 20

    values                         shift and go to state 30
    value                          shift and go to state 28

state 22

    (10) input -> FGETS LPAREN . RPAREN SEMICOLON

    RPAREN          shift and go to state 31


state 23

    (19) function -> FUNCTION NAMEFUNCTION . LPAREN parameter RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 32


state 24

    (22) function -> NAMEFUNCTION LPAREN . parameter RPAREN
    (20) parameter -> . IDENTIFIER
    (21) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 34

    parameter                      shift and go to state 33

state 25

    (23) return -> RETURN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 35


state 26

    (7) print -> PRINT LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 36


state 27

    (9) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 37


state 28

    (11) values -> value .
    (12) values -> value . COMMA values

    RPAREN          reduce using rule 11 (values -> value .)
    SEMICOLON       reduce using rule 11 (values -> value .)
    COMMA           shift and go to state 38


state 29

    (8) print -> PRINT value SEMICOLON .

    $end            reduce using rule 8 (print -> PRINT value SEMICOLON .)


state 30

    (6) assignment -> IDENTIFIER ASSINGMENT values . SEMICOLON

    SEMICOLON       shift and go to state 39


state 31

    (10) input -> FGETS LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 40


state 32

    (19) function -> FUNCTION NAMEFUNCTION LPAREN . parameter RPAREN CURLYLEFTBRACKET
    (20) parameter -> . IDENTIFIER
    (21) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 34

    parameter                      shift and go to state 41

state 33

    (22) function -> NAMEFUNCTION LPAREN parameter . RPAREN

    RPAREN          shift and go to state 42


state 34

    (20) parameter -> IDENTIFIER .
    (21) parameter -> IDENTIFIER . COMMA parameter

    RPAREN          reduce using rule 20 (parameter -> IDENTIFIER .)
    COMMA           shift and go to state 43


state 35

    (23) return -> RETURN IDENTIFIER SEMICOLON .

    $end            reduce using rule 23 (return -> RETURN IDENTIFIER SEMICOLON .)


state 36

    (7) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 44


state 37

    (9) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 9 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 38

    (12) values -> value COMMA . values
    (11) values -> . value
    (12) values -> . value COMMA values
    (13) value -> . INTEGER
    (14) value -> . FLOAT
    (15) value -> . IDENTIFIER
    (16) value -> . TRUE
    (17) value -> . FALSE
    (18) value -> . STRING

    INTEGER         shift and go to state 15
    FLOAT           shift and go to state 16
    IDENTIFIER      shift and go to state 17
    TRUE            shift and go to state 18
    FALSE           shift and go to state 19
    STRING          shift and go to state 20

    value                          shift and go to state 28
    values                         shift and go to state 45

state 39

    (6) assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .

    $end            reduce using rule 6 (assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .)


state 40

    (10) input -> FGETS LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 10 (input -> FGETS LPAREN RPAREN SEMICOLON .)


state 41

    (19) function -> FUNCTION NAMEFUNCTION LPAREN parameter . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 46


state 42

    (22) function -> NAMEFUNCTION LPAREN parameter RPAREN .

    $end            reduce using rule 22 (function -> NAMEFUNCTION LPAREN parameter RPAREN .)


state 43

    (21) parameter -> IDENTIFIER COMMA . parameter
    (20) parameter -> . IDENTIFIER
    (21) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 34

    parameter                      shift and go to state 47

state 44

    (7) print -> PRINT LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 7 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 45

    (12) values -> value COMMA values .

    RPAREN          reduce using rule 12 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 12 (values -> value COMMA values .)


state 46

    (19) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 48


state 47

    (21) parameter -> IDENTIFIER COMMA parameter .

    RPAREN          reduce using rule 21 (parameter -> IDENTIFIER COMMA parameter .)


state 48

    (19) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 19 (function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .)

