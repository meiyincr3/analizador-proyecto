Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    ANDEQUAL
    APOSTROPHE
    ARRAY
    ARROW
    ATTACH
    BREAK
    CASE
    CATCH
    CLASS
    COLON
    COMMENTS
    CONTAINS
    CONTINUE
    COUNT
    CURLYRIGHTBRACKET
    CURRENT
    DECLARE
    DECREMENT
    DEFAULT
    DIE
    DIVIDE
    DO
    DOLLARSIGN
    DOT
    DOUBLECOLON
    ECHO
    ELSE
    ELSEIF
    ENDFOR
    ENDFOREACH
    ENDIF
    EQUALS
    EXIT
    EXTENDS
    FIXEDARRAY
    FOR
    FOREACH
    GOTO
    GREATERTHAN
    GREATERTHANEQ
    HEAP
    IDENTICAL
    IF
    INCREMENT
    INTDIVIDE
    LBRACKET
    LESSTHAN
    LESSTHANEQ
    MAXHEAP
    MINHEAP
    MINUS
    MODULE
    NEW
    NOTIDENTICAL
    OBJECTSTORAGE
    OR
    PLUS
    POP
    POWERBY
    PRIORITYQUEUE
    PUBLIC
    PUSH
    QUEUE
    RBRACKET
    SIMPLEARROW
    STACK
    STATIC
    SWITCH
    TIMES
    TRY
    WHILE
    XOR

Grammar

Rule 0     S' -> sentence
Rule 1     sentence -> print
Rule 2     sentence -> printf
Rule 3     sentence -> assignment
Rule 4     sentence -> input
Rule 5     sentence -> function
Rule 6     sentence -> return
Rule 7     assignment -> IDENTIFIER ASSINGMENT values SEMICOLON
Rule 8     print -> PRINT LPAREN values RPAREN SEMICOLON
Rule 9     print -> PRINT value SEMICOLON
Rule 10    print -> PRINT LPAREN RPAREN SEMICOLON
Rule 11    printf -> PRINTF LPAREN values RPAREN SEMICOLON
Rule 12    input -> FGETS LPAREN values RPAREN SEMICOLON
Rule 13    values -> value
Rule 14    values -> value COMMA values
Rule 15    value -> INTEGER
Rule 16    value -> FLOAT
Rule 17    value -> IDENTIFIER
Rule 18    value -> TRUE
Rule 19    value -> FALSE
Rule 20    value -> STRING
Rule 21    function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
Rule 22    parameter -> IDENTIFIER
Rule 23    parameter -> IDENTIFIER COMMA parameter
Rule 24    function -> NAMEFUNCTION LPAREN parameter RPAREN
Rule 25    return -> RETURN IDENTIFIER SEMICOLON

Terminals, with rules where they appear

AND                  : 
ANDEQUAL             : 
APOSTROPHE           : 
ARRAY                : 
ARROW                : 
ASSINGMENT           : 7
ATTACH               : 
BREAK                : 
CASE                 : 
CATCH                : 
CLASS                : 
COLON                : 
COMMA                : 14 23
COMMENTS             : 
CONTAINS             : 
CONTINUE             : 
COUNT                : 
CURLYLEFTBRACKET     : 21
CURLYRIGHTBRACKET    : 
CURRENT              : 
DECLARE              : 
DECREMENT            : 
DEFAULT              : 
DIE                  : 
DIVIDE               : 
DO                   : 
DOLLARSIGN           : 
DOT                  : 
DOUBLECOLON          : 
ECHO                 : 
ELSE                 : 
ELSEIF               : 
ENDFOR               : 
ENDFOREACH           : 
ENDIF                : 
EQUALS               : 
EXIT                 : 
EXTENDS              : 
FALSE                : 19
FGETS                : 12
FIXEDARRAY           : 
FLOAT                : 16
FOR                  : 
FOREACH              : 
FUNCTION             : 21
GOTO                 : 
GREATERTHAN          : 
GREATERTHANEQ        : 
HEAP                 : 
IDENTICAL            : 
IDENTIFIER           : 7 17 22 23 25
IF                   : 
INCREMENT            : 
INTDIVIDE            : 
INTEGER              : 15
LBRACKET             : 
LESSTHAN             : 
LESSTHANEQ           : 
LPAREN               : 8 10 11 12 21 24
MAXHEAP              : 
MINHEAP              : 
MINUS                : 
MODULE               : 
NAMEFUNCTION         : 21 24
NEW                  : 
NOTIDENTICAL         : 
OBJECTSTORAGE        : 
OR                   : 
PLUS                 : 
POP                  : 
POWERBY              : 
PRINT                : 8 9 10
PRINTF               : 11
PRIORITYQUEUE        : 
PUBLIC               : 
PUSH                 : 
QUEUE                : 
RBRACKET             : 
RETURN               : 25
RPAREN               : 8 10 11 12 21 24
SEMICOLON            : 7 8 9 10 11 12 25
SIMPLEARROW          : 
STACK                : 
STATIC               : 
STRING               : 20
SWITCH               : 
TIMES                : 
TRUE                 : 18
TRY                  : 
WHILE                : 
XOR                  : 
error                : 

Nonterminals, with rules where they appear

assignment           : 3
function             : 5
input                : 4
parameter            : 21 23 24
print                : 1
printf               : 2
return               : 6
sentence             : 0
value                : 9 13 14
values               : 7 8 11 12 14

Parsing method: LALR

state 0

    (0) S' -> . sentence
    (1) sentence -> . print
    (2) sentence -> . printf
    (3) sentence -> . assignment
    (4) sentence -> . input
    (5) sentence -> . function
    (6) sentence -> . return
    (8) print -> . PRINT LPAREN values RPAREN SEMICOLON
    (9) print -> . PRINT value SEMICOLON
    (10) print -> . PRINT LPAREN RPAREN SEMICOLON
    (11) printf -> . PRINTF LPAREN values RPAREN SEMICOLON
    (7) assignment -> . IDENTIFIER ASSINGMENT values SEMICOLON
    (12) input -> . FGETS LPAREN values RPAREN SEMICOLON
    (21) function -> . FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET
    (24) function -> . NAMEFUNCTION LPAREN parameter RPAREN
    (25) return -> . RETURN IDENTIFIER SEMICOLON

    PRINT           shift and go to state 8
    PRINTF          shift and go to state 9
    IDENTIFIER      shift and go to state 10
    FGETS           shift and go to state 11
    FUNCTION        shift and go to state 12
    NAMEFUNCTION    shift and go to state 13
    RETURN          shift and go to state 14

    sentence                       shift and go to state 1
    print                          shift and go to state 2
    printf                         shift and go to state 3
    assignment                     shift and go to state 4
    input                          shift and go to state 5
    function                       shift and go to state 6
    return                         shift and go to state 7

state 1

    (0) S' -> sentence .



state 2

    (1) sentence -> print .

    $end            reduce using rule 1 (sentence -> print .)


state 3

    (2) sentence -> printf .

    $end            reduce using rule 2 (sentence -> printf .)


state 4

    (3) sentence -> assignment .

    $end            reduce using rule 3 (sentence -> assignment .)


state 5

    (4) sentence -> input .

    $end            reduce using rule 4 (sentence -> input .)


state 6

    (5) sentence -> function .

    $end            reduce using rule 5 (sentence -> function .)


state 7

    (6) sentence -> return .

    $end            reduce using rule 6 (sentence -> return .)


state 8

    (8) print -> PRINT . LPAREN values RPAREN SEMICOLON
    (9) print -> PRINT . value SEMICOLON
    (10) print -> PRINT . LPAREN RPAREN SEMICOLON
    (15) value -> . INTEGER
    (16) value -> . FLOAT
    (17) value -> . IDENTIFIER
    (18) value -> . TRUE
    (19) value -> . FALSE
    (20) value -> . STRING

    LPAREN          shift and go to state 15
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    IDENTIFIER      shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22

    value                          shift and go to state 16

state 9

    (11) printf -> PRINTF . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 23


state 10

    (7) assignment -> IDENTIFIER . ASSINGMENT values SEMICOLON

    ASSINGMENT      shift and go to state 24


state 11

    (12) input -> FGETS . LPAREN values RPAREN SEMICOLON

    LPAREN          shift and go to state 25


state 12

    (21) function -> FUNCTION . NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET

    NAMEFUNCTION    shift and go to state 26


state 13

    (24) function -> NAMEFUNCTION . LPAREN parameter RPAREN

    LPAREN          shift and go to state 27


state 14

    (25) return -> RETURN . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 28


state 15

    (8) print -> PRINT LPAREN . values RPAREN SEMICOLON
    (10) print -> PRINT LPAREN . RPAREN SEMICOLON
    (13) values -> . value
    (14) values -> . value COMMA values
    (15) value -> . INTEGER
    (16) value -> . FLOAT
    (17) value -> . IDENTIFIER
    (18) value -> . TRUE
    (19) value -> . FALSE
    (20) value -> . STRING

    RPAREN          shift and go to state 30
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    IDENTIFIER      shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22

    values                         shift and go to state 29
    value                          shift and go to state 31

state 16

    (9) print -> PRINT value . SEMICOLON

    SEMICOLON       shift and go to state 32


state 17

    (15) value -> INTEGER .

    SEMICOLON       reduce using rule 15 (value -> INTEGER .)
    COMMA           reduce using rule 15 (value -> INTEGER .)
    RPAREN          reduce using rule 15 (value -> INTEGER .)


state 18

    (16) value -> FLOAT .

    SEMICOLON       reduce using rule 16 (value -> FLOAT .)
    COMMA           reduce using rule 16 (value -> FLOAT .)
    RPAREN          reduce using rule 16 (value -> FLOAT .)


state 19

    (17) value -> IDENTIFIER .

    SEMICOLON       reduce using rule 17 (value -> IDENTIFIER .)
    COMMA           reduce using rule 17 (value -> IDENTIFIER .)
    RPAREN          reduce using rule 17 (value -> IDENTIFIER .)


state 20

    (18) value -> TRUE .

    SEMICOLON       reduce using rule 18 (value -> TRUE .)
    COMMA           reduce using rule 18 (value -> TRUE .)
    RPAREN          reduce using rule 18 (value -> TRUE .)


state 21

    (19) value -> FALSE .

    SEMICOLON       reduce using rule 19 (value -> FALSE .)
    COMMA           reduce using rule 19 (value -> FALSE .)
    RPAREN          reduce using rule 19 (value -> FALSE .)


state 22

    (20) value -> STRING .

    SEMICOLON       reduce using rule 20 (value -> STRING .)
    COMMA           reduce using rule 20 (value -> STRING .)
    RPAREN          reduce using rule 20 (value -> STRING .)


state 23

    (11) printf -> PRINTF LPAREN . values RPAREN SEMICOLON
    (13) values -> . value
    (14) values -> . value COMMA values
    (15) value -> . INTEGER
    (16) value -> . FLOAT
    (17) value -> . IDENTIFIER
    (18) value -> . TRUE
    (19) value -> . FALSE
    (20) value -> . STRING

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    IDENTIFIER      shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22

    values                         shift and go to state 33
    value                          shift and go to state 31

state 24

    (7) assignment -> IDENTIFIER ASSINGMENT . values SEMICOLON
    (13) values -> . value
    (14) values -> . value COMMA values
    (15) value -> . INTEGER
    (16) value -> . FLOAT
    (17) value -> . IDENTIFIER
    (18) value -> . TRUE
    (19) value -> . FALSE
    (20) value -> . STRING

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    IDENTIFIER      shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22

    values                         shift and go to state 34
    value                          shift and go to state 31

state 25

    (12) input -> FGETS LPAREN . values RPAREN SEMICOLON
    (13) values -> . value
    (14) values -> . value COMMA values
    (15) value -> . INTEGER
    (16) value -> . FLOAT
    (17) value -> . IDENTIFIER
    (18) value -> . TRUE
    (19) value -> . FALSE
    (20) value -> . STRING

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    IDENTIFIER      shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22

    values                         shift and go to state 35
    value                          shift and go to state 31

state 26

    (21) function -> FUNCTION NAMEFUNCTION . LPAREN parameter RPAREN CURLYLEFTBRACKET

    LPAREN          shift and go to state 36


state 27

    (24) function -> NAMEFUNCTION LPAREN . parameter RPAREN
    (22) parameter -> . IDENTIFIER
    (23) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 38

    parameter                      shift and go to state 37

state 28

    (25) return -> RETURN IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 39


state 29

    (8) print -> PRINT LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 40


state 30

    (10) print -> PRINT LPAREN RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 41


state 31

    (13) values -> value .
    (14) values -> value . COMMA values

    RPAREN          reduce using rule 13 (values -> value .)
    SEMICOLON       reduce using rule 13 (values -> value .)
    COMMA           shift and go to state 42


state 32

    (9) print -> PRINT value SEMICOLON .

    $end            reduce using rule 9 (print -> PRINT value SEMICOLON .)


state 33

    (11) printf -> PRINTF LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 43


state 34

    (7) assignment -> IDENTIFIER ASSINGMENT values . SEMICOLON

    SEMICOLON       shift and go to state 44


state 35

    (12) input -> FGETS LPAREN values . RPAREN SEMICOLON

    RPAREN          shift and go to state 45


state 36

    (21) function -> FUNCTION NAMEFUNCTION LPAREN . parameter RPAREN CURLYLEFTBRACKET
    (22) parameter -> . IDENTIFIER
    (23) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 38

    parameter                      shift and go to state 46

state 37

    (24) function -> NAMEFUNCTION LPAREN parameter . RPAREN

    RPAREN          shift and go to state 47


state 38

    (22) parameter -> IDENTIFIER .
    (23) parameter -> IDENTIFIER . COMMA parameter

    RPAREN          reduce using rule 22 (parameter -> IDENTIFIER .)
    COMMA           shift and go to state 48


state 39

    (25) return -> RETURN IDENTIFIER SEMICOLON .

    $end            reduce using rule 25 (return -> RETURN IDENTIFIER SEMICOLON .)


state 40

    (8) print -> PRINT LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 49


state 41

    (10) print -> PRINT LPAREN RPAREN SEMICOLON .

    $end            reduce using rule 10 (print -> PRINT LPAREN RPAREN SEMICOLON .)


state 42

    (14) values -> value COMMA . values
    (13) values -> . value
    (14) values -> . value COMMA values
    (15) value -> . INTEGER
    (16) value -> . FLOAT
    (17) value -> . IDENTIFIER
    (18) value -> . TRUE
    (19) value -> . FALSE
    (20) value -> . STRING

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    IDENTIFIER      shift and go to state 19
    TRUE            shift and go to state 20
    FALSE           shift and go to state 21
    STRING          shift and go to state 22

    value                          shift and go to state 31
    values                         shift and go to state 50

state 43

    (11) printf -> PRINTF LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 51


state 44

    (7) assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .

    $end            reduce using rule 7 (assignment -> IDENTIFIER ASSINGMENT values SEMICOLON .)


state 45

    (12) input -> FGETS LPAREN values RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 52


state 46

    (21) function -> FUNCTION NAMEFUNCTION LPAREN parameter . RPAREN CURLYLEFTBRACKET

    RPAREN          shift and go to state 53


state 47

    (24) function -> NAMEFUNCTION LPAREN parameter RPAREN .

    $end            reduce using rule 24 (function -> NAMEFUNCTION LPAREN parameter RPAREN .)


state 48

    (23) parameter -> IDENTIFIER COMMA . parameter
    (22) parameter -> . IDENTIFIER
    (23) parameter -> . IDENTIFIER COMMA parameter

    IDENTIFIER      shift and go to state 38

    parameter                      shift and go to state 54

state 49

    (8) print -> PRINT LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 8 (print -> PRINT LPAREN values RPAREN SEMICOLON .)


state 50

    (14) values -> value COMMA values .

    RPAREN          reduce using rule 14 (values -> value COMMA values .)
    SEMICOLON       reduce using rule 14 (values -> value COMMA values .)


state 51

    (11) printf -> PRINTF LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 11 (printf -> PRINTF LPAREN values RPAREN SEMICOLON .)


state 52

    (12) input -> FGETS LPAREN values RPAREN SEMICOLON .

    $end            reduce using rule 12 (input -> FGETS LPAREN values RPAREN SEMICOLON .)


state 53

    (21) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN . CURLYLEFTBRACKET

    CURLYLEFTBRACKET shift and go to state 55


state 54

    (23) parameter -> IDENTIFIER COMMA parameter .

    RPAREN          reduce using rule 23 (parameter -> IDENTIFIER COMMA parameter .)


state 55

    (21) function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .

    $end            reduce using rule 21 (function -> FUNCTION NAMEFUNCTION LPAREN parameter RPAREN CURLYLEFTBRACKET .)

